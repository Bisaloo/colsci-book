[["index.html", "The pavo handbook: studying biological colouration in R Chapter 1 Package Overview 1.1 Classes and Attributes 1.2 Suggestions and Assistance 1.3 Citation of methods implemented in pavo 1.4 Acknowledgements", " The pavo handbook: studying biological colouration in R 2021-02-13 Chapter 1 Package Overview pavo is an R package developed with the goal of establishing a flexible and integrated workflow for working with spectral and spatial colour data. It includes functions that take advantage of new data classes to work seamlessly from importing raw spectra and images, to visualisation and analysis. It provides flexible ways to input spectral data from a variety of equipment manufacturers, process these data, extract variables, and produce publication-quality figures. pavo was written with the following workflow in mind: Organise data by importing and processing spectral and image data (e.g., to remove noise, negative values, smooth curves, etc.). Analyse the resulting files, using spectral analyses of shape (hue, saturation, brightness), visual models based on perceptual data, and/or spatial adjacency and boundary strength analyses. Visualise the output, with multiple options provided for exploration and analysis. Figure 1.1: A non-exhaustive overview of the colour-pattern analysis workflow in pavo, as of version 2.0, displaying some key functions at each stage. In the remaining chapters we begin by detailing the importing, processing and visualisation of spectral and image data, before moving on to discussion of the many analyses that pavo allows. Our hope is to demonstrate the flexibility of pavo, and to provide a cohesive, reproducible workflow for colour pattern analysis within R. As always, the development version of pavo can be found on github, while the stable release is available via CRAN. 1.1 Classes and Attributes To enable the comprehensive workflow of pavo, we’ve implemented an expanded class system. Spectra will be of class rspec as long as we use one of pavo’s spectral import or processing functions, or explicitly convert an object using as.rspec(). Similarly, images will be of class rimg when imported via getimg(), or if converted using as.rimg(). The results of vismodel() are objects of class vismodel and the results of colspace() are, unsurprisingly, objects of class colspace. Most of these classes inherit from data.frame, and contain a suite of attributes that describe the object’s characteristics (e.g. options used in visual modelling such as the selected visual system and illuminant, and properties of the modelled colourspace). These are easily viewed using the summary function (on any rspec, rimg, vismodel, or colspace object), which will return the attributes and summary data (where appropriate) in a readable format. 1.2 Suggestions and Assistance For suggestions, assistance and/or bug reports, we suggest getting in touch via the colRverse discussion board. It requires a github account, however, so if you don’t have and/or want one the feel free to just email Tom and we’ll get back to you as soon as possible. If you have a bug to report, we’d appreciate it if you could also include a reproducible example when possible. Users familiar with GitHub may prefer to open an issue on the project’s github page, or to make a pull-request directly. 1.3 Citation of methods implemented in pavo Most of the methods implemented in pavo have been thoroughly described in their original publications, to which users should refer for details and interpretation. For reflectance shape variables (“objective colourimetrics”) and their particular relation to signal production and perception, see Andersson and Prager (2006) and Montgomerie (2006). Visual models based on photon catches and receptor noise are detailed in Vorobyev et al. (1998) and Vorobyev et al. (1998), and photoreceptor sensitivity curve estimation in Govardovskii et al. (2000) and Hart and Vorobyev (2005). For tetrahedral colourspace model implementations and variable calculations, see Endler and Mielke (2005) and Stoddard and Prum (2008), and for colour volume overlap see Stoddard and Prum (2008) and Stoddard and Stevens (2011). Adjacency and boundary strength analyses are described in Endler (2012) and Endler, Cole, and Kranz (2018), while overall pattern contrast is detailed in Endler and Mielke (2005). Users of the functions that apply these methods must cite the original sources as appropriate, along with pavo itself. 1.4 Acknowledgements We would like to thank Matthew D. Shawkey and Stephanie M. Doucet for insights and support, and Jarrod D. Hadfield and Mary Caswell Stoddard for sharing code that helped us develop some of pavo’s capabilities. References "],["importing-processing-and-visualising-data.html", "Chapter 2 Importing, Processing, and Visualising Data 2.1 Organizing Spectral Data 2.2 Processing Spectral Data 2.3 Visualizing Spectral Data 2.4 Organizing Spatial (image) Data 2.5 Visualising Image Data 2.6 Processing Image Data", " Chapter 2 Importing, Processing, and Visualising Data 2.1 Organizing Spectral Data Let’s begin by loading the package. # Load the package, and set a global random-number seed for the reproducible generation of fake data later on. library(pavo) set.seed(1612217) 2.1.1 Spectral Dataset Description The raw spectral data used in this example are available from the package repository on github, located here. You can download and extract it to follow the vignette exactly. Alternatively, the data are included as an RData file as part of the package installation, and so can be loaded directly (see below). The data consist of reflectance spectra, obtained using Avantes equipment and software, from seven bird species: Northern Cardinal Cardinalis cardinalis, Wattled Jacana Jacana jacana, Baltimore Oriole Icterus galbula, Peach-fronted Parakeet Aratinga aurea, American Robin Turdus migratorius, and Sayaca Tanager Thraupis sayaca. Several individuals were measured (sample size varies by species), and 3 spectra were collected from each individual. However, the number of individuals measured per species is uneven and the data have additional peculiarities that should emphasize the flexibility pavo offers, as we’ll see below. In addition, pavo includes three datasets that can be called with the data() function. data(teal), data(sicalis), and data(flowers) will all be used in this vignette. See the help files for each dataset for more information; via ?teal, ?sicalis, and ?flowers. 2.1.2 Importing The first thing we need to do is import spectral data into R using the function getspec(). It’s worth noting that getspec() is simply a wrapper for lr_get_spec() from the package lightr, which is a more specialised and feature-rich package for the import of spectral data and metadata (Gruson, White, and Maia 2019). Since the example spectra were obtained using Avantes software, we will need to specify that the files have the .ttt extension. Further, the data is organized in subdirectories for each species. getspec() will search through subdirectories recursively, and may include the names of the subdirectories in the spectra name if desired. getspec() also uses parallel processing thanks to the future package. You can check the documentation (?future::plan()) for more details but an easy way to set up parallel processing in most cases is to use the plan(\"multiprocess\") command. A final issue with the data is that it was collected using a computer with international numbering input, which means it uses commas instead of periods as a decimal separator. We can specify that in the function call. If, for example, the raw spectral files were downloaded and placed in a directory called /pavo/data_external/vignette, you might execute the following command and see this output: specs &lt;- getspec(&quot;~/pavo/data_external/vignette&quot;, ext = &quot;ttt&quot;, decimal = &quot;,&quot;, subdir = TRUE, subdir.names = FALSE) # 213 files found; importing spectra # |================================================================================| 100%, ETA 00:00 For convenience, however, we’ve included the spectra as an RData file in the package installation, and so will simply load it directly. specs &lt;- readRDS(system.file(&quot;extdata/specsdata.rds&quot;, package = &quot;pavo&quot;)) And we can inspect the resulting object: specs[1:10, 1:4] ## wl cardinal.0001 cardinal.0002 cardinal.0003 ## 1 300 5.7453 8.0612 8.0723 ## 2 301 6.0181 8.3926 8.8669 ## 3 302 5.9820 8.8280 9.0680 ## 4 303 6.2916 8.7621 8.7877 ## 5 304 6.6277 8.6819 9.3450 ## 6 305 6.3347 9.6016 9.4834 ## 7 306 6.3189 9.5712 9.3533 ## 8 307 6.7951 9.4650 9.9492 ## 9 308 7.0758 9.4677 9.8587 ## 10 309 7.2126 10.6172 10.5396 dim(specs) # the data set has 213 spectra, from 300 to 700 nm, plus a &#39;wl&#39; column ## [1] 401 214 When pavo imports spectra, it creates an object of class rspec, which inherits attributes from the data.frame class: is.rspec(specs) ## [1] TRUE If you already have multiple spectra in a single data frame that you’d like to use with pavo functions, you can use the command as.rspec() to convert it to an rspec object. The function will attempt to identify the wavelength variable or you can specify the column containing wavelengths with the whichwl argument. The default way that as.rspec() handles reflectance data is to interpolate the data in 1-nm bins, as is commonly done for spectral analyses. However, this can be turned off by using: interp = FALSE. As an example, we will create some fake reflectance data, name the column containing wavelengths (in 0.5-nm bins) wavelength rather than wl (required for pavo functions to work) and also put the column containing wavelengths third rather than first. # Create some fake reflectance data with wavelength column arbitrarily titled # and not first in the data frame: fakedat &lt;- data.frame( refl1 = rnorm(n = 801), refl2 = rnorm(n = 801), wavelength = seq(300, 700, by = .5) ) head(fakedat) ## refl1 refl2 wavelength ## 1 -0.032893386 0.5059612 300.0 ## 2 -0.478552738 -1.1526035 300.5 ## 3 -0.190687886 -1.0708952 301.0 ## 4 -0.008977959 -1.9871907 301.5 ## 5 -0.443133039 -0.3910143 302.0 ## 6 0.032110206 -0.5403221 302.5 is.rspec(fakedat) ## [1] FALSE fakedat.new &lt;- as.rspec(fakedat) ## wavelengths found in column 3 ## The spectral data contain 443 negative value(s), which may produce unexpected results if used in models. Consider using procspec() to correct them. is.rspec(fakedat.new) ## [1] TRUE head(fakedat.new) ## wl refl1 refl2 ## 1 300 -0.03289339 0.50596119 ## 2 301 -0.19068789 -1.07089518 ## 3 302 -0.44313304 -0.39101435 ## 4 303 -0.52064707 0.84403232 ## 5 304 1.42813472 0.07150436 ## 6 305 -0.19044804 -0.84504226 As can be seen, as.rspec() renames the column containing wavelengths, sets it as the first column, interpolates the data in 1-nm bins and converts the data to an rspec object. Note that the same output is returned with specifying whichwl = 3: head(as.rspec(fakedat, whichwl = &#39;wavelength&#39;)) ## The spectral data contain 443 negative value(s), which may produce unexpected results if used in models. Consider using procspec() to correct them. ## wl refl1 refl2 ## 1 300 -0.03289339 0.50596119 ## 2 301 -0.19068789 -1.07089518 ## 3 302 -0.44313304 -0.39101435 ## 4 303 -0.52064707 0.84403232 ## 5 304 1.42813472 0.07150436 ## 6 305 -0.19044804 -0.84504226 Finally, the lim argument allows you to specify the range of wavelengths contained in the input dataset. This is useful either in the case that the dataset doesn’t contain this information (and hence you cannot specify the column with whichwl or automatically find the column with as.rspec()). Additionally, it may be useful to focus on a subset of wavelengths. In our example, the wavelengths ranged from 300 to 700 nm, however you could also specify a restricted range of wavelengths with lim: fakedat.new2 &lt;- as.rspec(fakedat, lim = c(300, 500)) ## wavelengths found in column 3 ## The spectral data contain 231 negative value(s), which may produce unexpected results if used in models. Consider using procspec() to correct them. plot(refl1 ~ wl, type = &quot;l&quot;, data = fakedat.new2) We want to stress that it is important to check the actual wavelengths contained in the data before setting this argument (as.rspec() will warn you when wavelengths in the data are not present in the range specified with lim), otherwise as.rspec() will assume that wavelengths exist when in fact they may not. For example, if we set lim = c(300, 1000) and plot the results, the reflectance values between 700 and 1000 nm are set to be equal since there is no information at these wavelengths in the original dataset: fakedat.new2 &lt;- as.rspec(fakedat, lim = c(300, 1000)) ## wavelengths found in column 3 ## Warning in as.rspec(fakedat, lim = c(300, 1000)): Interpolating beyond the range ## of actual data. Check &#39;lim&#39; and `exceed.range` arguments to confirm this is the ## desired behaviour. ## The spectral data contain 743 negative value(s), which may produce unexpected results if used in models. Consider using procspec() to correct them. plot(fakedat.new2[, 2] ~ fakedat.new2[, 1], type = &quot;l&quot;) 2.1.3 Subsetting and Merging Spectral Data Once an rspec object has been created, either by importing raw spectral data or converting a dataset with the as.rspec() function, you can subset the spectra based on their names using a modified version of R’s built-in subset function. For example, the following code illustrates how to create an rspec object containing only tanagers: specs.tanager1 &lt;- subset(specs, &quot;tanager&quot;) head(specs.tanager1)[1:5] ## wl tanager.0001 tanager.0002 tanager.0003 tanager.0004 ## 1 300 10.0618 10.6744 10.1499 13.7473 ## 2 301 11.1472 10.8054 9.8003 14.3102 ## 3 302 10.7819 10.6134 9.5607 14.4463 ## 4 303 11.0210 11.2037 10.4107 15.5533 ## 5 304 10.2177 11.2120 9.9452 14.3841 ## 6 305 11.5664 11.6135 10.8659 15.6445 The subset function here is using partial matching to find all spectra with the string “tanager” in their name. To fully benefit from this flexible subsetting functionality, it is important that you follow a consistent file naming scheme. For example, tanager.14423.belly.001.ttt would indicate the species (tanager), individual ID (14423), body patch (belly) and measurement number (001). Additionally, we suggest that labels used should have the same number of characters, which simplifies character string manipulation and subsetting based on partial matching. If you prefer not to use partial matching, subset will also work if you provide a logical condition, similar to the default subset behaviour in R. For example: # extract first component of filenames containing species names spp &lt;- do.call(rbind, strsplit(names(specs), &quot;\\\\.&quot;))[, 1] # subset specs.tanager2 &lt;- subset(specs, subset = spp == &quot;tanager&quot;) # compare subsetting methods all.equal(specs.tanager1, specs.tanager2) ## [1] TRUE Note that subset will also work with visual model (class vismodel) and colspace (class colspace) objects, as described below. Another useful function is merge. Let’s say that you have subsetted spectra for tanagers and parakeets, and you would like to re-combine them for an analysis. The following lines of code show how to do this: specs.tanager &lt;- subset(specs, &quot;tanager&quot;) specs.parakeet &lt;- subset(specs, &quot;parakeet&quot;) specs.new &lt;- merge(specs.tanager, specs.parakeet) Note that this re-combined file (specs.new) has only a single wl column with the merged spectra as columns. Keep in mind that the order of objects in merge will determine the order of columns in the final merged object (i.e. tanagers will be before parakeets). 2.2 Processing Spectral Data 2.2.1 Averaging Spectra As previously described, our data (contained in the specs object) consists of multiple individuals, and each was measured three times, as is common to avoid measurement bias. A good way to visualize the repeatability of our measurements is to plot the spectra of each individual separately. The function explorespec() provides an easy way of doing so. You may specify the number of spectra to be plotted in the same panel using the argument specreps, and the function will adjust the number of panels per page accordingly. We will exemplify this function using only the 12 cardinal individuals measured: # 36 spectra plus the first (wl) column explorespec(specs[, 1:37], by = 3, lwd = 2) Figure 2.1: Result from explorespec, showing the three measurements for each individual cardinal in separate panels So our first step would be to take the average of each of these three measurements to obtain average individual spectra to be used in further analyses. This is easily accomplished using the aggspec() function. The by argument can be either a number (specifying how many specs should be averaged for each new sample) or a vector specifying the identities of the spectra to be combined (see below): mspecs &lt;- aggspec(specs, by = 3, FUN = mean) mspecs[1:5, 1:4] ## wl cardinal cardinal.1 cardinal.2 ## 1 300 7.292933 5.676700 6.387233 ## 2 301 7.759200 5.806700 6.698200 ## 3 302 7.959333 5.858467 6.910500 ## 4 303 7.947133 6.130267 7.357567 ## 5 304 8.218200 6.127933 7.195267 dim(mspecs) # data now has 71 spectra, one for each individual, and the &#39;wl&#39; column ## [1] 401 72 Now we’ll use the aggspec() function again, but this time to take the average spectrum for each species. However, each species has a different number of samples, so we can’t use the by argument as before. Instead we will use regular expressions to create a species name vector by removing the numbers that identify individual spectra: # create a vector with species identity names spp &lt;- gsub(&#39;\\\\.[0-9].*$&#39;, &#39;&#39;, names(mspecs))[-1] table(spp) ## spp ## cardinal jacana oriole parakeet robin tanager ## 12 9 9 13 10 18 Instead, we are going to use the spp vector we created to tell the aggspec() function how to average the spectra in mspecs: sppspec &lt;- aggspec(mspecs, by = spp, FUN = mean) round(sppspec[1:5, ], 2) ## wl cardinal jacana oriole parakeet robin tanager ## 1 300 7.05 7.33 3.89 7.63 3.98 9.02 ## 2 301 7.25 7.35 3.91 7.75 3.91 9.53 ## 3 302 7.44 7.45 4.13 7.89 4.19 9.41 ## 4 303 7.82 8.09 4.39 8.49 4.51 10.20 ## 5 304 7.84 7.71 4.18 8.66 4.07 9.68 2.2.2 Normalizing and Smoothing Spectra Data obtained from spectrometers often requires further processing before analysis and/or publication. For example, electrical noise can produce unwanted “spikes” in reflectance curves. The pavo function procspec() can handle a variety of processing techniques. For example, the reflectance curve from the parakeet is noisy in the short (300-400 nm) and long (650-700 nm) wavelength ranges (see Figure below, black line). To eliminate this noise, we will use local regression smoothing implemented by the loess.smooth() function in R, wrapped in the opt=\"smooth\" argument of procspec(). But first, let’s use the plotsmooth() function to determine a suitable smoothing parameter (span). This function allows you to set a minimum and maximum smoothing parameter to try and plots the resulting curves against the unsmoothed (raw) data in a convenient multipanel figure. plotsmooth(sppspec, minsmooth = 0.05, maxsmooth = 0.5, curves = 4, ask = FALSE) From the resulting plot, we can see that span = 0.2 is the minimum amount of smoothing to remove spectral noise while preserving the original spectral shape. Based on this value, we will now use the opt argument in procspec() to smooth data for further plotting and analysis. spec.sm &lt;- procspec(sppspec, opt = &quot;smooth&quot;, span = 0.2) ## processing options applied: ## smoothing spectra with a span of 0.2 plot(sppspec[, 5] ~ sppspec[, 1], type = &quot;l&quot;, lwd = 10, col = &quot;grey&quot;, xlab = &quot;Wavelength (nm)&quot;, ylab = &quot;Reflectance (%)&quot; ) lines(spec.sm[, 5] ~ sppspec[, 1], col = &quot;red&quot;, lwd = 2) Figure 2.2: Result for raw (grey line) and smoothed (red line) reflectance data for the parakeet We can also try different normalisations. Options include subtracting the minimum reflectance of a spectrum at all wavelengths (effectively making the minimum reflectance equal to zero, opt = \"min\", left panel, below) and making the reflectance at all wavelength proportional to the maximum reflectance (i.e. setting maximum reflectance to 1; opt = \"max\", centre panel, below). Note that the user can specify multiple processing options that will be applied sequentially to the spectral data by procspec() (right panel, below). # Run some different normalisations specs.max &lt;- procspec(sppspec, opt = &quot;max&quot;) ## processing options applied: ## Scaling spectra to a maximum value of 1 specs.min &lt;- procspec(sppspec, opt = &quot;min&quot;) ## processing options applied: ## Scaling spectra to a minimum value of zero specs.str &lt;- procspec(sppspec, opt = c(&quot;min&quot;, &quot;max&quot;)) # multiple options ## processing options applied: ## Scaling spectra to a minimum value of zero ## Scaling spectra to a maximum value of 1 # Plot results plot(specs.min[, 5] ~ c(300:700), xlab = &quot;&quot;, ylab = &quot;&quot;, type = &quot;l&quot;) abline(h = 0, lty = 2) plot(specs.max[, 5] ~ c(300:700), ylim = c(0, 1), xlab = &quot;&quot;, ylab = &quot;&quot;, type = &quot;l&quot;) abline(h = c(0, 1), lty = 2) plot(specs.str[, 5] ~ c(300:700), type = &quot;l&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;) abline(h = c(0, 1), lty = 2) mtext(&quot;Wavelength (nm)&quot;, side = 1, outer = TRUE, line = 1) mtext(&quot;Normalised reflectance (%)&quot;, side = 2, outer = TRUE, line = 1) Figure 2.3: Results for min (left), max (centre), and both normalisations (right) 2.2.3 Binning and PCA Analysis of Spectral Shape Another intended usage of procspec() is preparation of spectral data for dimensionality reduction (for example, using Principal Component Analysis, or PCA). Following Cuthill et al. (1999), we can use opt = 'center' to centre spectra to have a mean reflectance of zero (thus removing brightness as a dominant variable in the PCA) and then bin the spectra into user-defined bins (using the opt = 'bin' argument) to obtain a dataframe suitable for the PCA. # PCA analysis spec.bin &lt;- procspec(sppspec, opt = c(&quot;bin&quot;, &quot;center&quot;)) ## processing options applied: ## Centering spectra to a mean of zero ## binned spectra to 21-nm intervals head(spec.bin) ## wl cardinal jacana oriole parakeet robin tanager ## 1 300 -12.991747 -15.98282 -17.78389 -5.187601 -10.043001 -9.61852071 ## 2 321 -8.754302 -15.22013 -15.67409 -3.497942 -9.751455 -6.74685034 ## 3 342 -5.490538 -14.60414 -14.58129 -3.695973 -9.454188 -2.77517997 ## 4 363 -4.639077 -14.17163 -15.03655 -5.552378 -9.222658 -0.14415405 ## 5 384 -5.563199 -14.48320 -16.68218 -7.387742 -8.880768 -0.03173553 ## 6 405 -8.639736 -14.92472 -17.86635 -8.574752 -8.326391 -1.44428182 spec.bin &lt;- t(spec.bin) # transpose so wavelength are variables for the PCA colnames(spec.bin) &lt;- spec.bin[1, ] # names variables as wavelength bins spec.bin &lt;- spec.bin[-1, ] # remove &#39;wl&#39; column pca1 &lt;- prcomp(spec.bin, scale. = TRUE) summary(pca1) ## Importance of components: ## PC1 PC2 PC3 PC4 PC5 PC6 ## Standard deviation 3.6016 1.9885 1.5791 0.6678 0.36656 4.351e-16 ## Proportion of Variance 0.6486 0.1977 0.1247 0.0223 0.00672 0.000e+00 ## Cumulative Proportion 0.6486 0.8463 0.9710 0.9933 1.00000 1.000e+00 As can be seen by the summary, PC1 explains approximately 64% of the variation in spectral shape and describes the ratio of short to long wavelengths reflected. The flexibility of R and pavo’s plotting capabilities allows you to sort spectra by another variable (e.g., PC1 loading) and then plot in a stacked format using the plot function. # Generate colours from spectra colr &lt;- spec2rgb(sppspec) wls &lt;- as.numeric(colnames(spec.bin)) # Rank specs by PC1 sel &lt;- rank(pca1$x[, 1]) sel &lt;- match(names(sort(sel)), names(sppspec)) # Plot results plot(pca1$rotation[, 1] ~ wls, type = &quot;l&quot;, ylab = &quot;PC1 loading&quot;) abline(h = 0, lty = 2) plot(sppspec, select = sel, labels.stack = names(sppspec)[sel], type = &quot;s&quot;, col = colr) mtext(&quot;Wavelength (nm)&quot;, side = 1, outer = TRUE, line = 1) Figure 2.4: Plot of PC1 loading versus wavelength (left) and species mean spectra sorted vertically from lowest to highest PC1 value (right; values on right hand axis are column identities). 2.2.4 Dealing With Negative Values in Spectra Negative values in spectra are unwanted, as they are uninterpretable (how can there be less than zero light reflected by a surface?) and can affect estimates of colour variables. Nonetheless, certain spectrometer manufacturers allow negative values to be saved. To handle negative values, the procspec() function has an argument called fixneg. The two options available are (1) adding the absolute value of the most negative value to the whole spectrum with addmin, and (2) changing all negative values to zero with zero. # Create a duplicate spectrum and add some negative values refl &lt;- sppspec[, 7] - 20 testspecs &lt;- as.rspec(cbind(c(300:700), refl)) ## wavelengths found in column 1 ## The spectral data contain 188 negative value(s), which may produce unexpected results if used in models. Consider using procspec() to correct them. # Apply two different processing options testspecs.fix1 &lt;- procspec(testspecs, fixneg = &quot;addmin&quot;) ## processing options applied: ## Negative value correction: added min to all reflectance testspecs.fix2 &lt;- procspec(testspecs, fixneg = &quot;zero&quot;) ## processing options applied: ## Negative value correction: converted negative values to zero # Plot it plot(testspecs, select = 2, ylim = c(-10, 30)) abline(h = 0, lty = 3) plot(testspecs.fix1, select = 2, ylim = c(-10, 30)) abline(h = 0, lty = 3) plot(testspecs.fix2, select = 2, ylim = c(-10, 30)) abline(h = 0, lty = 3) mtext(&quot;Wavelength (nm)&quot;, side = 1, outer = TRUE, line = 1) mtext(&quot;Reflectance (%)&quot;, side = 2, outer = TRUE, line = 1) Figure 2.5: Plots showing original reflectance curve including negative values (left) and two processed curves using fixneg = addmin (center) and fixneg = zero (right). These manipultions may have different effects on the final spectra, which the user should keep in mind and use according to the final goal of the analysis. For example, by adding the minimum reflectance to all other wavelength, the shape of the curve is preserved, but the maximum reflectance is much higher. On the other hand, substituting negative values with zero preserves absolute reflectance values, but may cause the spectral shape to be lost. The “best” transformation will depend on the severity of the problem of negative values and the goal of the analysis (e.g. will reflectance intensity be used? What is more important, to preserve reflectance values or the total shape of the curve?). Which correction to use would also depend on the source of the negative values. If they are thought to originate from improper calibration of the spectrophotometer, fixneg = addmin would be appropriate. However, if they are thought to originate from electric noise, fixneg = zero would be more appropriate. 2.3 Visualizing Spectral Data pavo offers three main plotting functions. The main one is plot, which combines several different options in a flexible framework for most commonly used purposes. The explorespec() function aims at providing initial exploratory analysis, as demonstrated in Section 1. Finally, aggplot() provides a simple framework for publication-quality plots of aggregated spectral data. 2.3.1 The plot Function Options Since pavo uses the class rspec to identify spectral data, the function plot.rspec() can be called simply by calling plot(data). If the object is not of class rspec the multivariate visualisation methods will not work as expected, so it might be useful to check the data using is.rspec() and convert with as.rspec() if necessary. We have implemented three methods of visualizing spectral data using plot: Overlay: all spectra plotted with same x- and y-axis Stack: spectra plotted with same x-axis but arranged vertically along y-axis Heatmap: false colour map to illustrate three dimensional data These options are in addition to the exploratory plotting offered by explorespec(), as seen in the figures in section 1. To showcase the capabilities of plot.rspec(), we will use the teal dataset included in pavo. This dataset consists of reflectance spectra from the iridescent wing patch of a green-winged teal (Anas carolinensis). Reflectance measurements were taken between 300 and 700 nm at different incident angles, ranging from 15° to 70° (in 5° increments) (Eliason and Shawkey 2012). Figure 2.6: Anas carolinensis, by pixabay user Cock-Robin, CC0 2.3.1.1 The overlay Option We can start out by visualizing these spectra with the overlay option in plot. Another neat option pavo offers is to convert reflectance spectra to their approximate perceived colour, by using the function spec2rgb(). This can make for some very interesting plots and even exploratory data analysis, as shown above. data(teal) plot(teal, type = &quot;o&quot;, col = spec2rgb(teal)) Figure 2.7: Overlay plot of the teal angle-dependent reflectance with colours of each curve being an approximation of the perceived colour. 2.3.1.2 The stack Option Another option is the stack plot (again, with human vision approximations of the colour produced by the spectra using spec2rgb()). teal.norm &lt;- procspec(teal, opt = c(&quot;min&quot;, &quot;max&quot;)) ## processing options applied: ## Scaling spectra to a minimum value of zero ## Scaling spectra to a maximum value of 1 plot(teal, type = &quot;s&quot;, col = spec2rgb(teal)) plot(teal.norm, type = &quot;s&quot;, col = spec2rgb(teal)) mtext(&quot;Wavelength (nm)&quot;, side = 1, outer = T, line = 1) mtext(&quot;Cumulative reflectance (A.U.)&quot;, side = 2, outer = T, line = 1) Figure 2.8: Stacked plot of the raw (left) and normalized (right) teal angle-dependent reflectance Note that in the above figure, the y axis to the right includes the index of each spectrum. This makes it easier to identify and subset specific spectra or groups of spectra using the select argument in plot.rspec(). Note also that the first index is actually 2, preserving the sequence in the original dataset (since the first column is wavelength). Though this may seem confusing at first (“why is my first spec number 2?”) this preserves subsetting hierarchy: using plot(teal, select = 2) will show the same spectra that would be selected if you use teal[ ,2]. 2.3.1.3 The heatmap Option Since this dataset is three-dimensional (containing wavelengths, reflectance values and incident angles) we can also use the heatmap function. First, it will be necessary to define a vector for the incident angles each spectrum was measured at: angles &lt;- seq(15, 70, by = 5) Next, we will smooth the data with procspec() and plot as a false colour map (heatmap): # Smooth the spectral data teal.sm &lt;- procspec(teal, opt = c(&quot;smooth&quot;)) ## processing options applied: ## smoothing spectra with a span of 0.25 # Plot it as a heatmap plot(teal.sm, type = &quot;h&quot;, varying = angles, ylab = expression(paste(&quot;Incident angle (&quot;, degree, &quot;)&quot;)), las = 1, useRaster = TRUE ) Figure 2.9: Heatmap plot for angle-resolved reflectance measurements of the green-winged teal. These plots can be very useful to observe changes over time, for example, or any other type of continuous variation. 2.3.2 The aggplot() Function aggplot() has a very similar interface to aggspec(), allowing for quick plotting of aggregated spectra combined by a factor, such as species, sex, experimental treatment, and so on. Its main output is a plot with lines of group mean spectra outlined by a shaded area indicating some measure of variability, such as the standard deviation of the group. Note that functions that aren’t already implemented in R must be passed like they would be to functions such as apply (e.g., function(x) sd(x)/sqrt(length(x)) in the example below). # Plot using median and standard deviation, default colours aggplot(mspecs, spp, FUN.center = median, ylim = c(0, 70), alpha = 0.3, legend = TRUE) # Plot using mean and standard error, in greyscale aggplot(mspecs, spp, ylim = c(0, 70), FUN.error = function(x) sd(x) / sqrt(length(x)), lcol = 1, shadecol = &quot;grey&quot;, alpha = 0.7) Figure 2.10: Example plots created using aggplot. Left: using median, standard deviation, and coloured lines. Right: using mean, standard error, and greyscale 2.4 Organizing Spatial (image) Data We first import our images with getimg(), which functions in a similar manner to getspec(). Since we are importing more than one image, we can simply point the function to the folder containing the images, and it will use parallel processing (where possible) to import any jpg, bmp, or png images in the folder. As with the raw spectra, these images are also available at the package repository [here][data-location], but are included in the package installation for convenience. butterflies &lt;- getimg(system.file(&quot;testdata/images/&quot;, package = &#39;pavo&#39;)) ## 2 files found; importing images. When pavo imports images, it created a multidimensional object of class rimg, which inherits from the array class. If more than one image is imported, then these rimg objects are stored as elements in a list. All image-based functions in pavo are capable of working with such rimg lists, which allows for a more convenient and tidy high-throughput workflow. Note that while pavo will allow you to load, manipulate, and analyse as many images as your computer’s memory allows, it will throw a message if the total size of images in memory is greater than ca. 200mb, as this will result in noticeably slowed performance (everything will still work, it will just be slow). This may be ameliorated by reducing the size of individual images, such as through procimg(), or by processing images in smaller batches. All rimg objects have a number of identifying attributes, drawn on by image-processing functions, which can be readily inspected. is.rimg(butterflies) ## [1] TRUE str(butterflies[[1]]) ## &#39;rimg&#39; num [1:500, 1:340, 1:3] 1 1 1 1 1 1 1 1 1 1 ... ## - attr(*, &quot;state&quot;)= chr &quot;raw&quot; ## - attr(*, &quot;imgname&quot;)= chr &quot;h_melpomene&quot; ## - attr(*, &quot;px_scale&quot;)= logi NA ## - attr(*, &quot;raw_scale&quot;)= logi NA ## - attr(*, &quot;k&quot;)= logi NA ## - attr(*, &quot;outline&quot;)= logi NA ## - attr(*, &quot;colnames&quot;)= logi NA ## - attr(*, &quot;tag_loc&quot;)= logi NA str(butterflies[[2]]) ## &#39;rimg&#39; num [1:500, 1:398, 1:3] 0.988 1 1 1 1 ... ## - attr(*, &quot;state&quot;)= chr &quot;raw&quot; ## - attr(*, &quot;imgname&quot;)= chr &quot;papilio&quot; ## - attr(*, &quot;px_scale&quot;)= logi NA ## - attr(*, &quot;raw_scale&quot;)= logi NA ## - attr(*, &quot;k&quot;)= logi NA ## - attr(*, &quot;outline&quot;)= logi NA ## - attr(*, &quot;colnames&quot;)= logi NA ## - attr(*, &quot;tag_loc&quot;)= logi NA If you already have images loaded into R, you can convert them to rimg objects using as.rimg(). The function will attempt to interpret a multidimensional array as an RGB image with values ranging between [0, 1], and imbue it with the custom attributes of an rimg. We can see this by creating a fake array, before converting it. fakeimg &lt;- array(c( matrix(c(1, 1, 0, 0), nrow = 12, ncol = 8), matrix(c(0, 0, 0, 0), nrow = 12, ncol = 8), matrix(c(0, 0, 1, 1), nrow = 12, ncol = 8)), dim = c(12, 8, 3) ) fake_rimg &lt;- as.rimg(fakeimg) is.rimg(fake_rimg) ## [1] TRUE str(fake_rimg) ## &#39;rimg&#39; num [1:12, 1:8, 1:3] 1 1 0 0 1 1 0 0 1 1 ... ## - attr(*, &quot;state&quot;)= chr &quot;raw&quot; ## - attr(*, &quot;imgname&quot;)= chr &quot;img&quot; ## - attr(*, &quot;px_scale&quot;)= logi NA ## - attr(*, &quot;raw_scale&quot;)= logi NA ## - attr(*, &quot;k&quot;)= logi NA ## - attr(*, &quot;outline&quot;)= logi NA ## - attr(*, &quot;colnames&quot;)= logi NA ## - attr(*, &quot;tag_loc&quot;)= logi NA 2.5 Visualising Image Data 2.5.1 The plot and summary Functions Thanks to the underlying class system of pavo, the generic functions plot and summary recognise and respond to image-data in an appropriate manner, as is the case with spectral data. A quick call to plot, for example, prints our images. Note that while we call an image individually below (for convenient printing in the vignette), we could simply feed the entire list of images to plot and it would automatically step through each image in the list upon user input. # Note the plot titles are taken from the file names, and can be overridden. plot(butterflies[[1]]) Figure 2.11: Raw images of our butterflies The summary function offers some summary information about images or lists of images as we might expect. If we specify plot = TRUE however, the function instead plots the image. When such images have been colour-classified this also plots the images’ colour palette alongside (see below). This is an extremely useful diagnostic tool when classifying images, as it allows us to see how well the classification algorithm has performed in clustering colour pattern elements into discrete colour categories. As with all plots, the function takes all standard plot arguments (see ?par), such as custom colours, which again can be diagnostically useful. 2.6 Processing Image Data 2.6.1 Overview Images often require some post-capture processing, depending on the intended use, and pavo offers some useful options via procimg(). The functionality of procimg() is currently limited to only that which is closely relevant to the analyses currently implemented, as we assume any major processing and quality-checking (e.g. image rotation and colour correction) is undertaken by the user beforehand. However, should users with to keep their image processing within the R ecosystem, there now exist several excellent image-processing packages such as imager and magick, which pavo can seamlessly work with. Indeed, the functions rimg2cimg() and rimg2magick() convert images from pavo preferred structure to that used by imager (with the reverse simply achieved via as.rimg()), which simplifies the transitions between these packages. 2.6.2 Setting Scales and Defining Objects The functionality of procimg() is currently centred on rotating and resizing images, setting a real-world image scale, and/or distinguishing the focal object from its background. Rotating an image simply requires inputting an angle, in degrees, by which the image is rotated about its centre, while resizing requires a scaling factor by which the size of image(s) are to be decreased or increased. Setting scales and distinguishing backgrounds, in contrast, are both interactive procedures, meaning that we are presented with the focal image and must select points on it using the mouse (either a line, when setting a scale, or a polygon when identifying the focus). If setting a scale, we specify a scale in our preferred units via scaledist, and then click the endpoints of the scale within the image (which could be a ‘formal’ scale, or simply the length of a wing or another known reference object). This information, as usual, is attached to the image as an attribute. # Interactively specify the real-world scale of the image. Here 100 mm. butterflies &lt;- procimg(butterflies, scaledist = 100) Distinguishing a focal object from its background is important in cases where we are analysing a broader visual scene, particularly when the background is highly heterogeneous, such as an animal in nature, and cannot be classified into a homogeneous block and identified more simply (see below). To define the object and background we specify outline = TRUE, which will result in being asked to click around the outline of the focal object in each image, which is then converted to a polygon — the xy coordinates of which are saved as an attribute. It is often useful to slightly smooth the resulting polygon, which can be done with Chaikin’s corner-cutting algorithm by specifying a number of refinements. Chaikin’s algorithm works by iteratively replacing every point by two new points 1/4 of the way to the next. The argument iterations specifies the number of corner cutting iterations to apply, and the default value of 1 offers a subtle smoothing effect. # Interactively specify a smoothed polygon around the focal objects butterflies &lt;- procimg(butterflies, outline = TRUE, iterations = 1) All of these options can be simultaneously specified in a single call to procimg(), and the pavo 2.0 publication offers a useful example of such processing, since the more involved features are difficult to illustrate here due to their interactive nature. References "],["analysing-data.html", "Chapter 3 Analysing Data 3.1 Analysing Spectral Data 3.2 Analysing Spatial Data", " Chapter 3 Analysing Data Let’s again begin by loading the package. # Load the package, and set a global random-number seed for the reproducible generation of fake data later on. library(pavo) set.seed(1612217) 3.1 Analysing Spectral Data 3.1.1 Spectral Dataset Description The raw spectral data used in this example are available from the package repository on github, located here. You can download and extract it to follow the vignette exactly. Alternatively, the data are included as an RData file as part of the package installation, and so can be loaded directly (see below). The data consist of reflectance spectra, obtained using Avantes equipment and software, from seven bird species: Northern Cardinal Cardinalis cardinalis, Wattled Jacana Jacana jacana, Baltimore Oriole Icterus galbula, Peach-fronted Parakeet Aratinga aurea, American Robin Turdus migratorius, and Sayaca Tanager Thraupis sayaca. Several individuals were measured (sample size varies by species), and 3 spectra were collected from each individual. However, the number of individuals measured per species is uneven and the data have additional peculiarities that should emphasize the flexibility pavo offers, as we’ll see below. In addition, pavo includes three datasets that can be called with the data function. data(teal), data(sicalis), and data(flowers) will all be used in this vignette. See the help files for each dataset for more information; via ?teal, ?sicalis, and ?flowers. specs &lt;- readRDS(system.file(&quot;extdata/specsdata.rds&quot;, package = &quot;pavo&quot;)) mspecs &lt;- aggspec(specs, by = 3, FUN = mean) spp &lt;- gsub(&#39;\\\\.[0-9].*$&#39;, &#39;&#39;, names(mspecs))[-1] sppspec &lt;- aggspec(mspecs, by = spp, FUN = mean) spec.sm &lt;- procspec(sppspec, opt = &quot;smooth&quot;, span = 0.2) ## processing options applied: ## smoothing spectra with a span of 0.2 3.1.2 Overview pavo offers two main approaches for spectral data analysis. First, colour variables can be calculated based on the shape of the reflectance spectra. By using special R classes for spectra data frame objects, this can easily be done using the summary function with an rspec object (see below). The function peakshape() also returns descriptors for individual peaks in spectral curves, as outlined below. Second, reflectance spectra can be analysed by accounting for the visual system receiving the colour signal, therefore representing reflectance spectra as perceived colours. To that end, we have implemented a suite of visual models and colourspaces including; the receptor-noise limited model of model of Vorobyev et al. (1998), Endler (1990)’s segment classification method, flexible di- tri- and tetra-chromatic colourspaces, the Hexagon model of Chittka (1992), the colour-opponent coding space of Backhaus (1991), CIELAB and CIEXYZ spaces, and the categorical model of Troje (1993). 3.1.3 Spectral Shape Analysis 3.1.3.1 Colourimetric Variables Obtaining colourimetric variables (pertaining to hue, saturation and brightness/value) is pretty straightforward in pavo. Since reflectance spectra is stored in an object of class rspec, the summary function recognizes the object as such and extracts 23 variables, as outlined in Montgomerie (2006) (and reproduced here). Though outlined in a book chapter on bird colouration, these variables are broadly applicable to any reflectance data, particularly if the taxon of interest has colour vision within the UV-human visible range. The description and formulas for these variables can be found by running ?summary.rspec. summary(spec.sm) ## B1 B2 B3 S1U S1V S1B S1G ## cardinal 8984.266 22.40465 52.70167 0.16614848 0.19110215 0.11783711 0.1898843 ## jacana 9668.503 24.11098 53.78744 0.09601072 0.11022142 0.19494363 0.3079239 ## oriole 9108.474 22.71440 54.15508 0.07484472 0.08323604 0.05728179 0.3254691 ## parakeet 6020.733 15.01430 29.86504 0.16792815 0.18501247 0.14407795 0.4244676 ## robin 5741.392 14.31769 37.85542 0.08503645 0.10014331 0.14428130 0.2673730 ## tanager 8515.251 21.23504 30.48108 0.20322408 0.23904955 0.26133545 0.3198724 ## S1Y S1R S2 S3 S4 S5 S6 ## cardinal 0.2519174 0.5333116 7.607769 0.2954315 0.20287401 4003.465 45.77432 ## jacana 0.2482692 0.4083129 7.101897 0.2471677 0.05315822 3314.024 46.21377 ## oriole 0.3624909 0.5492239 14.507969 0.2986678 0.08730015 5233.013 50.42230 ## parakeet 0.3395961 0.2718894 5.111074 0.4483808 0.27397999 1894.018 24.02183 ## robin 0.2668138 0.5100635 9.130156 0.3031501 NA 2532.414 33.70923 ## tanager 0.2430666 0.2238857 3.226417 0.3343114 0.16775097 1106.471 21.03373 ## S7 S8 S9 S10 H1 H2 H3 H4 H5 ## cardinal -0.2055325 2.043072 0.83791691 0.4144862 700 419 587 0.02130606 581 ## jacana -0.3054756 1.916710 0.73309578 0.1018889 700 593 529 0.71519543 468 ## oriole -0.5847404 2.219838 0.92483219 0.1937922 700 382 551 0.41436251 544 ## parakeet 0.6656480 1.599931 0.58642273 0.4383490 572 618 634 0.97835569 506 ## robin -0.1076722 2.354377 0.81473611 NA 700 NA 593 0.42040115 631 ## tanager -0.7851970 0.990520 -0.04551277 0.1661607 557 594 362 1.52666571 518 summary also takes an additional argument subset which if changed from the default FALSE to TRUE will return only the most commonly used colourimetrics (Andersson and Prager 2006). summary can also take a vector of colour variable names, which can be used to filter the results summary(spec.sm, subset = TRUE) ## B2 S8 H1 ## cardinal 22.40465 2.043072 700 ## jacana 24.11098 1.916710 700 ## oriole 22.71440 2.219838 700 ## parakeet 15.01430 1.599931 572 ## robin 14.31769 2.354377 700 ## tanager 21.23504 0.990520 557 # Extract only brightness variables summary(spec.sm, subset = c(&#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;)) ## B1 B2 B3 ## cardinal 8984.266 22.40465 52.70167 ## jacana 9668.503 24.11098 53.78744 ## oriole 9108.474 22.71440 54.15508 ## parakeet 6020.733 15.01430 29.86504 ## robin 5741.392 14.31769 37.85542 ## tanager 8515.251 21.23504 30.48108 3.1.3.2 Peak Shape Descriptors Particularly in cases of reflectance spectra that have multiple discrete peaks (in which case the summary function will only return variables based on the tallest peak in the curve), it might be useful to obtain variables that describe individual peak’s properties. The peakshape() function identifies the peak location (H1), returns the reflectance at that point (B3), and identifies the wavelengths at which the reflectance is half that at the peak, calculating the wavelength bandwidth of that interval (the Full Width at Half Maximum, or FWHM). The function also returns the half widths, which are useful when the peaks are located near the edge of the measurement limit and half maximum reflectance can only be reliably estimated from one of its sides. If this all sounds too esoteric, fear not: peakshape() has the option of returning plots indicating what it’s calculating. The vertical continuous red line indicates the peak location, the horizontal continuous red line indicates the half-maximum reflectance, and the distance between the dashed lines (HWHM.l and HWHM.r) is the FWHM: peakshape(spec.sm, plot = TRUE) ## id B3 H1 FWHM HWHM.l HWHM.r incl.min ## 1 cardinal 52.70167 700 NA 114 NA Yes ## 2 jacana 53.78744 700 NA 172 NA Yes ## 3 oriole 54.15508 700 NA 149 NA Yes ## 4 parakeet 29.86504 572 126 63 63 Yes ## 5 robin 37.85542 700 NA 107 NA Yes ## 6 tanager 30.48108 557 166 81 85 Yes Figure 3.1: Plots from peakshape As it can be seen, the variable FWHM is meaningless if the curve doesn’t have a clear peak. Sometimes, such as in the case of the Cardinal (Above figure, first panel), there might be a peak which is not the point of maximum reflectance of the entire spectral curve. peakshape() also offers a select argument to facilitate subsetting the spectra data frame to, for example, focus on a single reflectance peak: peakshape(spec.sm, select = 2, lim = c(300, 500), plot = TRUE) Figure 3.2: Plot from peakshape, setting the wavelength limits to 300 and 500 nm ## id B3 H1 FWHM HWHM.l HWHM.r incl.min ## 1 cardinal 17.84381 369 100 46 54 Yes 3.1.4 Visual Modelling 3.1.4.1 Overview All visual and colourspace modelling and plotting options are wrapped into four main function: vismodel(), colspace(), coldist() (or its bootstrap-based variant bootcoldist()), and plot. As detailed below, these functions cover the basic processes common to most modelling approaches. Namely, the estimation of quantum catches, their conversion to an appropriate space, estimating the distances between samples, and visualising the results. As a brief example, a typical workflow for modelling might use: vismodel() to estimate photoreceptor quantum catches. The assumptions of visual models may differ dramatically, so be sure to select options that are appropriate for your intended use. colspace() to convert the results of vismodel() (or user-provided quantum catches) into points in a given colourspace, specified with the space argument. If no space argument is provided, colspace() will automatically select the di-, tri- or tetrahedral colourspace, depending on the nature of the input data. The result of colspace() will be an object of class colspace (that inherits from data.frame), and will contain the location of stimuli in the selected space along with any associated colour variables. coldist() or bootcoldist() to estimate the colour distances between points in a colourspace (if the input is from colspace), or the ‘perceptual,’ noise-weighted distances in the receptor-noise limited model (if the input is from vismodel() where relative = FALSE). plot the output. plot will automatically select the appropriate visualisation based on the input colspace object, and will also accept various graphical parameters depending on the colourspace (see ?plot.colspace and links therein for details). 3.1.4.2 Accessing and Plotting In-built Spectral Data All in-built spectral data in pavo can be easily retrieved and/or plotted via the sensdata() function. These data can be visualised directly by including plot = TRUE, or assigned to an object for subsequent use, as in: musca_sense &lt;- sensdata(visual = &quot;musca&quot;, achromatic = &quot;md.r1&quot;) head(musca_sense) ## wl musca.u musca.s musca.m musca.l md.r1 ## 1 300 0.01148992 0.006726680 0.001533875 0.001524705 0.001713692 ## 2 301 0.01152860 0.006749516 0.001535080 0.001534918 0.001731120 ## 3 302 0.01156790 0.006773283 0.001536451 0.001545578 0.001751792 ## 4 303 0.01160839 0.006798036 0.001537982 0.001556695 0.001775960 ## 5 304 0.01165060 0.006823827 0.001539667 0.001568283 0.001803871 ## 6 305 0.01169510 0.006850712 0.001541499 0.001580352 0.001835777 3.1.4.3 Visual Phenotypes pavo contains numerous di-, tri- and tetrachromatic visual systems, to accompany the suite of new models. The full complement of included systems are accessible via the vismodel() argument visual, and include: Table 3.1: Built-in visual phenotypes available in pavo phenotype description avg.uv average ultraviolet-sensitive avian (tetrachromat) avg.v average violet-sensitive avian (tetrachromat) bluetit The blue tit Cyanistes caeruleus (tetrachromat) star The starling Sturnus vulgaris (tetrachromat) pfowl The peafowl Pavo cristatus (tetrachromat) apis The honeybee Apis mellifera (trichromat) ctenophorus The ornate dragon lizard Ctenophorus ornatus (trichromat) canis The canid Canis familiaris (dichromat) musca The housefly Musca domestica (tetrachromat) cie2 2-degree colour matching functions for CIE models of human colour vision (trichromat) cie10 10-degree colour matching functions for CIE models of human colour vision (trichromat) segment A generic ‘viewer’ with broad sensitivities for use in the segment analysis of Endler (1990) (tetrachromat) habronattus The jumping spider Habronattus pyrrithrix (trichromat) rhinecanthus The triggerfish Rhinecanthus aculeatus (trichromat) 3.1.4.4 Estimating Quantum Catch Numerous models have been developed to understand how colours are perceived and discriminated by an individual’s or species’ visual system (described in detail in Endler 1990; Renoult, Kelber, and Schaefer 2017; Vorobyev et al. 1998). In essence, these models take into account the receptor sensitivity of the different receptors that make the visual system in question and quantify how a given colour would stimulate those receptors individually, and their combined effect on the perception of colour. These models also have an important component of assuming and interpreting the chromatic component of colour (hue and saturation) to be processed independently of the achromatic (brightness, or luminance) component. This provides a flexible framework allowing for a tiered model construction, in which information on aspects such as different illumination sources, backgrounds, and visual systems can be considered and compared. To apply any such model, we first need to quantify receptor excitation and then consider how the signal is being processed, while possibly considering the relative density of different cones and the noise-to-signal ratio. To quantify the stimulation of receptors by a given stimulus, we will use the function vismodel(). This takes an rspec dataframe as a minimal input, and the user can either select from the available options or input their own data for the additional arguments in the function: visual: the visual system to be used. Available inbuilt options are detailed above, or the user may include their own dataframe, with the first column being the wavelength range and the following columns being the absorbance at each wavelength for each cone type (see below for an example). achromatic: Either a receptor’s sensitivity data (available options include the blue tit, chicken, and starling double-cones, and the housefly’s R1-6 receptor), which can also be user-defined as above; or the longest-wavelength receptor, the sum of the two longest-wavelength receptors, or the sum of all receptors can be used. Alternatively, none can be specified for no achromatic stimulation calculation. illum: The illuminant being considered. By default, it considers an ideal white illuminant, but implemented options are a blue sky, standard daylight, and forest shade illuminants. A vector of same length as the wavelength range being considered can also be used as the input. trans: Models of the effects of light transmission (e.g. through noisy environments or ocular filters). The argument defaults to ideal (i.e. no effect), though users can also use the built-in options of bluetit or blackbird to model the ocular transmission of blue tits/blackbirds, or specify a user-defined vector containing transmission spectra. qcatch: This argument determines what photon catch data should be returned Qi: The receptor quantum catches, calculated for receptor \\(i\\) as: \\[Q_i = \\int_\\lambda{R_i(\\lambda)S(\\lambda)I(\\lambda)d\\lambda}\\] Where \\(\\lambda\\) denotes the wavelength, \\(R_i(\\lambda)\\) the spectral sensitivity of receptor \\(i\\), \\(S(\\lambda)\\) the reflectance spectrum of the colour, and \\(I(\\lambda)\\) the illuminant spectrum. fi: The receptor quantum catches transformed according to Fechner’s law, in which the signal of the receptor is proportional to the logarithm of the quantum catch i.e. \\(f_i = \\ln(Q_i)\\) Ei: the hyperbolic transform (a simplification of the Michaelis–Menten photoreceptor equation), where \\[E_i = \\frac{Q_i}{Q_i + 1}\\]. bkg: The background being considered. By default, it considers an idealized background (i.e. wavelength-independent influence of the background on colour). A vector of same length as the wavelength range being considered can also be used as the input. vonkries: a logical argument which determines if the von Kries transformation (which normalizes receptor quantum catches to the background, thus accounting for receptor adaptation) is to be applied (defaults to FALSE). If TRUE, \\(Q_i\\) is multiplied by a constant \\(k\\), which describes the von Kries transformation: \\[k_i = \\frac{1}{\\int_\\lambda R_i(\\lambda)S^b(\\lambda)I(\\lambda)d\\lambda}\\] Where \\(S^b\\) denotes the reflectance spectra of the background. scale: This argument defines how the illuminant should be scaled. The scale of the illuminant is critical for receptor noise models in which the signal intensity influences the noise (see Receptor noise section, below). Illuminant curves should be in units of \\(\\mu mol.s^{-1}.m^{-2}\\) in order to yield physiologically meaningful results. (Some software return illuminant information values in \\(\\mu Watt.cm^{-2}\\), and must be converted to \\(\\mu mol.s^{-1}.m^{-2}\\). This can be done by using the irrad2flux() and flux2irrad() functions.) Therefore, if the user-specified illuminant curves are not in these units (i.e. are measured proportional to a white standard, for example), the scale parameter can be used as a multiplier to yield curves that are at least a reasonable approximation of the illuminant value. Commonly used values are 500 for dim conditions and 10,000 for bright conditions. relative: If TRUE, it will make the cone stimulations relative to their sum. This is appropriate for general colourspace models(e.g. Goldsmith 1990; Stoddard and Prum 2008). For the receptor-noise model, however, it is important to set relative = FALSE. All visual models begin with the estimation of receptor quantum catches. The requirements of models may differ significantly of course, so be sure to consult the function documentation and original publications. For this example, we will use the average reflectance of the different species to calculate the raw stimulation of retinal cones, considering the avian average UV visual system, a standard daylight illumination, and an idealized background. vismod1 &lt;- vismodel(sppspec, visual = &quot;avg.uv&quot;, achromatic = &quot;bt.dc&quot;, illum = &quot;D65&quot;, relative = FALSE ) Since there are multiple parameters that can be used to customize the output of vismodel(), as detailed above, for convenience these can be returned by using summary in a vismodel object: summary(vismod1) ## visual model options: ## * Quantal catch: Qi ## * Visual system, chromatic: avg.uv ## * Visual system, achromatic: bt.dc ## * Illuminant: D65, scale = 1 (von Kries colour correction not applied) ## * Background: ideal ## * Transmission: ideal ## * Relative: FALSE ## u s m l ## Min. :0.01671 Min. :0.04199 Min. :0.1325 Min. :0.2092 ## 1st Qu.:0.02408 1st Qu.:0.06860 1st Qu.:0.1753 1st Qu.:0.2232 ## Median :0.03039 Median :0.07148 Median :0.2675 Median :0.2759 ## Mean :0.03599 Mean :0.09924 Mean :0.2338 Mean :0.3076 ## 3rd Qu.:0.04731 3rd Qu.:0.14265 3rd Qu.:0.2819 3rd Qu.:0.3815 ## Max. :0.06353 Max. :0.17648 Max. :0.3037 Max. :0.4625 ## lum ## Min. :0.1513 ## 1st Qu.:0.1966 ## Median :0.2247 ## Mean :0.2241 ## 3rd Qu.:0.2661 ## Max. :0.2766 We can visualise what vismodel() is doing when estimating quantum catches by comparing the reflectance spectra to the estimates they are generating: oldpar &lt;- par(no.readonly = TRUE) par(mfrow = c(2, 6), oma = c(3, 3, 0, 0)) layout(rbind(c(2, 1, 4 , 3, 6 , 5), c(1, 1, 3 , 3, 5 , 5), c(8, 7, 10, 9, 12, 11), c(7, 7, 9 , 9, 11, 11))) sppspecol &lt;- spec2rgb(sppspec) for (i in 1:6) { par(mar = c(2, 2, 2, 2)) plot(sppspec, select = i+1, col = sppspecol, lwd = 3, ylim = c(0, 100)) par(mar = c(4.1, 2.5, 2.5, 2)) barplot(as.matrix(vismod1[i, 1:4]), yaxt = &quot;n&quot;, col = &quot;black&quot;) } mtext(&quot;Wavelength (nm)&quot;, side = 1, outer = TRUE, line = 1) mtext(&quot;Reflectance (%)&quot;, side = 2, outer = TRUE, line = 1) Figure 3.3: Plots of species mean reflectance curves with corresponding relative usml cone stimulations (insets). par(oldpar) As described above, vismodel also accepts user-defined visual systems, background and illuminants. We will illustrate this by showcasing the function sensmodel, which models spectral sensitivities of retinas based on their peak cone sensitivity, as described in Govardovskii et al. (2000) and Hart and Vorobyev (2005). sensmodel takes several optional arguments, but the main one is a vector containing the peak sensitivities for the cones being modelled. Let’s model an idealized dichromat visual system, with cones peaking in sensitivity at 350 and 650 nm: idealizeddichromat &lt;- sensmodel(c(350, 650)) plot(idealizeddichromat, col = spec2rgb(idealizeddichromat), ylab = &quot;Absorbance&quot;) Figure 3.4: Idealized dichromat photoreceptors created using sensmodel. vismod.idi &lt;- vismodel(sppspec, visual = idealizeddichromat, relative = FALSE) vismod.idi ## lmax350 lmax650 lum ## cardinal 0.14578161 0.3519237 NA ## jacana 0.09155090 0.3179246 NA ## oriole 0.06981615 0.3775647 NA ## parakeet 0.10579320 0.1727374 NA ## robin 0.04727061 0.2174901 NA ## tanager 0.16438304 0.2148739 NA 3.1.4.5 The Receptor Noise Model The receptor-noise limited (RNL) model of Vorobyev et al. (1998), Vorobyev et al. (2001) offers a basis for estimating the ‘perceptual’ distance between coloured stimuli (depending on available physiological and behavioural data), and assumes that the simultaneous discrimination of colours is fundamentally limited by photoreceptor noise. Colour distances under the RNL model can be calculated by using the inverse of the noise-to-signal ratio, known as the Weber fraction (\\(w_i\\) for each cone \\(i\\)). The Weber fraction can be calculated from the noise-to-signal ratio of cone \\(i\\) (\\(v_i\\)) and the relative number of receptor cells of type \\(i\\) within the receptor field (\\(n_i\\)): \\[w_i = \\frac{v_i}{\\sqrt{n_i}}\\] \\(w_i\\) is the value used for the noise when considering only neural noise mechanisms. Alternatively, the model can consider that the intensity of the colour signal itself contributes to the noise (photoreceptor, or quantum, noise). In this case, the noise for a receptor \\(i\\) is calculated as: \\[w_i = \\sqrt{\\frac{v_i^2}{\\sqrt{n_i}} + \\frac{2}{Q_a+Q_b}}\\] where \\(a\\) and \\(b\\) refer to the two colour signals being compared. Note that when the values of \\(Q_a\\) and \\(Q_b\\) are very high, the second portion of the equation tends to zero, and the both formulas should yield similar results. Hence, it is important that the quantum catch are calculated in the appropriate illuminant scale, as described above. Colour distances are obtained by weighting the Euclidean distance of the photoreceptor quantum catches by the Weber fraction of the cones (\\(\\Delta S\\)). These measurements are in units of Just Noticeable Differences (JNDs), where distances over a certain threshold (usually 1) are considered to be discernible under the conditions considered (e.g., backgrounds, illumination). The equations used in these calculations are: For dichromats: \\[\\Delta S = \\sqrt{\\frac{(\\Delta f_1 - \\Delta f_2)^2}{w_1^2+w_2^2}}\\] For trichromats: \\[\\Delta S = \\sqrt{\\frac{w_1^2(\\Delta f_3 - \\Delta f_2)^2 + w_2^2(\\Delta f_3 - \\Delta f_1)^2 + w_3^2(\\Delta f_1 - \\Delta f_2)^2 }{ (w_1w_2)^2 + (w_1w_3)^2 + (w_2w_3)^2 }}\\] For tetrachromats: \\[\\Delta S = \\sqrt{(w_1w_2)^2(\\Delta f_4 - \\Delta f_3)^2 + (w_1w_3)^2(\\Delta f_4 - \\Delta f_2)^2 + (w_1w_4)^2(\\Delta f_3 - \\Delta f_2)^2 + \\\\ (w_2w_3)^2(\\Delta f_4 - \\Delta f_1)^2 + (w_2w_4)^2(\\Delta f_3 - \\Delta f_1)^2 + (w_3w_4)^2(\\Delta f_2 - \\Delta f_1)^2 / \\\\ ((w_1w_2w_3)^2 + (w_1w_2w_4)^2 + (w_1w_3w_4)^2 + (w_2w_3w_4)^2)}\\] For the chromatic contrast. The achromatic contrast (\\(\\Delta L\\)) can be calculated based on the double cone or the receptor (or combination of receptors) responsible for chromatic processing by the equation: \\[\\Delta L = \\frac{\\Delta f}{w}\\] 3.1.4.5.1 Noise-weighted Distances with coldist() and bootcoldist() pavo implements the noise-weighted colour distance calculations in the functions coldist() and bootcoldist(), assuming that raw receptor quantum catches are provided (via relative = FALSE in vismodel()). For the achromatic contrast, coldist() uses n4 to calculate \\(w\\) for the achromatic contrast. Note that even if \\(Q_i\\) is chosen, values are still log-transformed. This option is available in case the user wants to specify a data frame of quantum catches that was not generated by vismodel() as an input. In this case, the argument qcatch should be used to inform the function if \\(Q_i\\) or \\(f_i\\) values are being used (note that if the input to coldist() is an object generated using the vismodel() function, this argument is ignored.) The type of noise to be calculated can be selected from the coldist() argument noise (which accepts either \"neural\" or \"quantum\"). coldist(vismod1, noise = &quot;neural&quot;, achromatic = TRUE, n = c(1, 2, 2, 4), weber = 0.1, weber.achro = 0.1 ) ## patch1 patch2 dS dL ## 1 cardinal jacana 8.436191 3.6082787 ## 2 cardinal oriole 7.874540 3.5245174 ## 3 cardinal parakeet 8.010167 0.7553289 ## 4 cardinal robin 5.865464 2.4275512 ## 5 cardinal tanager 10.116173 2.2442493 ## 6 jacana oriole 10.114671 0.0837613 ## 7 jacana parakeet 4.316712 2.8529498 ## 8 jacana robin 3.499380 6.0358299 ## 9 jacana tanager 5.064380 1.3640294 ## 10 oriole parakeet 8.147778 2.7691885 ## 11 oriole robin 7.200079 5.9520686 ## 12 oriole tanager 13.532690 1.2802681 ## 13 parakeet robin 4.744364 3.1828801 ## 14 parakeet tanager 5.886396 1.4889204 ## 15 robin tanager 7.679779 4.6718005 coldist(vismod.idi, n = c(1, 2), weber = 0.1) ## patch1 patch2 dS dL ## 1 cardinal jacana 2.0993283 NA ## 2 cardinal oriole 4.6567462 NA ## 3 cardinal parakeet 2.2575457 NA ## 4 cardinal robin 3.7236780 NA ## 5 cardinal tanager 3.5417700 NA ## 6 jacana oriole 2.5574178 NA ## 7 jacana parakeet 4.3568740 NA ## 8 jacana robin 1.6243496 NA ## 9 jacana tanager 5.6410983 NA ## 10 oriole parakeet 6.9142918 NA ## 11 oriole robin 0.9330682 NA ## 12 oriole tanager 8.1985162 NA ## 13 parakeet robin 5.9812236 NA ## 14 parakeet tanager 1.2842244 NA ## 15 robin tanager 7.2654480 NA Where dS is the chromatic contrast (\\(\\Delta S\\)) and dL is the achromatic contrast (\\(\\Delta L\\)). Note that, by default, achromatic = FALSE, so dL isn’t included in the second result (this is to maintain consistency since, in the vismodel() function, the achromatic argument defaults to none). As expected, values are really high under the avian colour vision, since the colours of these species are quite different and because of the enhanced discriminatory ability with four compared to two cones. coldist() also has a subset argument, which is useful if only certain comparisons are of interest (for example, of colour patches against a background, or only comparisons among a species or body patch). subset can be a vector of length one or two. If only one subsetting option is passed, all comparisons against the matching argument are returned (useful in the case of comparing to a background, for example). If two values are passed, comparisons will only be made between samples that match that rule (partial string matching and regular expressions are accepted). For example, compare: coldist(vismod1, subset = &#39;cardinal&#39;) ## patch1 patch2 dS dL ## 1 cardinal jacana 8.436191 NA ## 2 cardinal oriole 7.874540 NA ## 3 cardinal parakeet 8.010167 NA ## 4 cardinal robin 5.865464 NA ## 5 cardinal tanager 10.116173 NA to: coldist(vismod1, subset = c(&#39;cardinal&#39;, &#39;jacana&#39;)) ## patch1 patch2 dS dL ## 1 cardinal jacana 8.436191 NA A bootstrap-based variant of coldist(), described in Maia and White (2018) as part of a more general analytical framework, is implemented via the function bootcoldist(). As the name suggests, bootcoldist() uses a bootstrap procedure to generate confidence intervals for the mean chromatic and/or achromatic distance between two or more samples of colours. This has the benefit of generating useful errors around distance estimates, which can be inspected for the inclusion of appropriate ‘threshold,’ when asking common kinds of questions that relate to between-group differences (e.g. animals-vs-backgrounds, sexual dichromatism, colour polymorphism). The function’s arguments are shared coldist() save for a few extra requirements. The by argument is used to specify a grouping variable that defines the groups to be compared, while boot.n and alpha control the number of bootstrap replicates and the confidence level for the confidence interval, respectively. The latter two have sensible defaults, but the by argument is required. Here we run present a quick example that tests for colour differences across three body regions (breast, crown, and throat) of the finch Sicalis citrina, given seven measures of each region from different males. # Load the data data(sicalis) # Construct a model using an avian viewer sicmod &lt;- vismodel(sicalis, visual = &#39;avg.uv&#39;, relative = FALSE) # Create a grouping variable to group by body region, # informed by the spectral data names regions &lt;- substr(rownames(sicmod), 6, 6) # Estimate bootstrapped colour-distances sicdist &lt;- bootcoldist(sicmod, by = regions, n = c(1, 2, 2, 4), weber = 0.05) # Take a look at the resulting pairwise estimates sicdist ## dS.mean dS.lwr dS.upr ## B-C 9.253097 5.7015179 14.013095 ## B-T 3.483528 0.3728945 9.509223 ## C-T 12.221038 8.1736179 16.899949 And plot the results for good measure. We can see that the pairwise comparisons of the chest, breast, and throat are quite chromatically distinct, but the breast and throat are much more similar in colour, perhaps to the point of being indistinguishable. plot(sicdist[, 1], ylim = c(0, 20), pch = 21, bg = 1, cex = 2, xaxt = &#39;n&#39;, xlab = &#39;Centroid comparison&#39;, ylab = &#39;Chromatic contrast (dS)&#39;) axis(1, at = 1:3, labels = rownames(sicdist)) segments(1:3, sicdist[, 2], 1:3, sicdist[, 3], lwd = 2) # Add CI&#39;s abline(h = 1, lty = 3, lwd = 2) # Add a &#39;threshold&#39; line at dS = 1 Figure 3.5: The bootstrapped colour distances between the throat, chest, and breast regions of male Sicalis citrina. 3.1.4.5.2 Converting receptor noise-corrected distances to Cartesian coordinates You can convert distances in JND back to Cartesian position coordinates with the function jnd2xyz(). Note that the actual position of these points in the XYZ space is arbitrary; therefore the function allows you to rotate the data so that, for example, the vector leading to the long-wavelength cone aligns with the X axis: fakedata1 &lt;- vapply( seq(100, 500, by = 20), function(x) rowSums(cbind( dnorm(300:700, x, 30), dnorm(300:700, x + 400, 30) )), numeric(401) ) # Creating idealized specs with varying saturation fakedata2 &lt;- vapply( c(500, 300, 150, 105, 75, 55, 40, 30), function(x) dnorm(300:700, 550, x), numeric(401) ) fakedata1 &lt;- as.rspec(data.frame(wl = 300:700, fakedata1)) fakedata1 &lt;- procspec(fakedata1, &quot;max&quot;) fakedata2 &lt;- as.rspec(data.frame(wl = 300:700, fakedata2)) fakedata2 &lt;- procspec(fakedata2, &quot;sum&quot;) fakedata2 &lt;- procspec(fakedata2, &quot;min&quot;) # Converting reflectance to percentage fakedata1[, -1] &lt;- fakedata1[, -1] * 100 fakedata2[, -1] &lt;- fakedata2[, -1] / max(fakedata2[, -1]) * 100 # Combining and converting to rspec fakedata.c &lt;- data.frame(wl = 300:700, fakedata1[, -1], fakedata2[, -1]) fakedata.c &lt;- as.rspec(fakedata.c) # Visual model and colour distances fakedata.vm &lt;- vismodel(fakedata.c, relative = FALSE, achromatic = &#39;all&#39;) fakedata.cd &lt;- coldist(fakedata.vm, noise = &quot;neural&quot;, n = c(1, 2, 2, 4), weber = 0.1, achromatic = TRUE ) # Converting to Cartesian coordinates fakedata.cc &lt;- jnd2xyz(fakedata.cd, ref1 = &quot;l&quot;, axis1 = c(1, 0, 0), ref2 = NULL) head(fakedata.cc) ## x y z lum ## X1 -26.165302 3.692783 -17.71718 1.430788 ## X2 -11.212399 -2.085407 -27.97937 2.315951 ## X3 3.076291 -7.441594 -37.76761 3.621349 ## X4 16.523287 -12.475488 -46.33606 4.341465 ## X5 25.812150 -17.848152 -40.71621 4.444027 ## X6 31.912643 -23.368560 -24.79660 4.046863 which you can then plot as well: plot(fakedata.cc, theta = 55, phi = 25, col = spec2rgb(fakedata.c)) Figure 3.6: Spectral data in a receptor noise-corrected colourspace The axes in this colourspace are in JND units. For more information on these functions, see ?jnd2xyz, ?jndrot and ?jndplot. 3.1.4.6 Colourspaces Another general, flexible way in which to represent stimuli is via a colour space model. Under such models photon catches are expressed in relative values (so that the quantum catches of all receptors involved in chromatic discrimination sum to 1). The maximum stimulation of each cone \\(n\\) is placed at the vertex of a \\((n-1)\\)-dimensional polygon that encompasses all theoretical colours that can be perceived by that visual system. For the avian visual system comprised of four cones, for example, all colours can be placed somewhere in the volume of a tetrahedron, in which each of the four vertices represents the maximum stimulation of that particular cone type. Though these models do not account for receptor noise (and thus do not allow an estimate of JNDs), they presents several advantages. First, they make for a very intuitive representation of colour points accounting for attributes of the colour vision of the signal receiver. Second, they allow for the calculation of several interesting variables that represent colour. For example, hue can be estimated from the angle of the point relative to the xy plane (blue-green-red) and the z axis (UV); saturation can be estimated as the distance of the point from the achromatic centre. data(flowers) is a new example dataset consisting of reflectance spectra from 36 Australian angiosperm species, which we’ll use to illustrate for the following colourspace modelling. data(flowers) head(flowers[1:4]) ## wl Goodenia_heterophylla Goodenia_geniculata Goodenia_gracilis ## 1 300 1.7426387 1.918962 0.3638354 ## 2 301 1.5724849 1.872966 0.3501921 ## 3 302 1.4099808 1.828019 0.3366520 ## 4 303 1.2547709 1.784152 0.3231911 ## 5 304 1.1064997 1.741398 0.3097854 ## 6 305 0.9648117 1.699792 0.2964107 3.1.4.6.1 Di-, Tri-, and Tetrachromatic Colourspaces pavo has extensive modelling and visualisation capabilities for generic di-, tri-, and tetra-chromatic spaces, uniting these approaches in a cohesive workflow. As with most colourspace models, we first estimate relative quantum catches with various assumptions by using the vismodel() function, before converting each set of values to a location in colourspace by using the space argument in colspace() (the function can also be set to try to detect the dimensionality of the colourspace automatically). For di- tri- and tetrachromatic spaces, colspace() calculates the coordinates of stimuli as: Dichromats: \\[x = \\frac{1}{\\sqrt{2}}(Q_l - Q_s)\\] Trichromats: \\[ \\begin{split} x &amp;= \\frac{1}{\\sqrt{2}}(Q_l - Q_m) \\\\ y &amp;= \\frac{\\sqrt{2}}{\\sqrt{3}}(Q_s - \\frac{Q_l + Q_m}{2}) \\end{split} \\] Tetrachromats: \\[ \\begin{split} x &amp;= \\frac{1}{\\sqrt{2}}(Q_l - Q_m) \\\\ y &amp;= \\frac{\\sqrt{2}}{\\sqrt{3}}(Q_s - \\frac{Q_l + Q_m}{2}) z &amp;= \\frac{\\sqrt{3}}{2}(Q_u - \\frac{Q_l + Q_m + Q_s}{3}) \\end{split} \\] Where \\(Q_u\\), \\(Q_s\\), \\(Q_m\\), and \\(Q_l\\) refer to quantum catch estimates for UV-, short, medium-, and long-wavelength photoreceptors, respectively. For a dichromatic example, we can model our floral reflectance data using the visual system of the domestic dog Canis familiaris, which has two cones with maximal sensitivity near 440 and 560 nm. vis.flowers &lt;- vismodel(flowers, visual = &#39;canis&#39;) di.flowers &lt;- colspace(vis.flowers, space = &#39;di&#39;) head(di.flowers) ## s l x r.vec lum ## Goodenia_heterophylla 0.52954393 0.4704561 -0.04178143 0.04178143 NA ## Goodenia_geniculata 0.25430150 0.7456985 0.34747015 0.34747015 NA ## Goodenia_gracilis 0.01747832 0.9825217 0.68238870 0.68238870 NA ## Xyris_operculata 0.39433933 0.6056607 0.14942675 0.14942675 NA ## Eucalyptus_sp 0.40628552 0.5937145 0.13253229 0.13253229 NA ## Faradaya_splendida 0.23166580 0.7683342 0.37948187 0.37948187 NA The output contains values for the relative stimulation of short- and long-wavelength sensitive photoreceptors associated with each flower, along with its single coordinate in dichromatic space and its r.vector (distance from the origin). To visualise where these points lie, we can simply plot them on a segment. plot(di.flowers, col = spec2rgb(flowers)) Figure 3.7: Flowers in a dichromatic colourspace, as modelled according to a canid visual system. For our trichromatic viewer we can use the honeybee Apis mellifera, one of the most significant and widespread pollinators. We’ll also transform our quantum catches according to Fechner’s law by specifying qcatch = 'fi', and will model photoreceptor stimulation under bright conditions by scaling our illuminant with the scale argument. vis.flowers &lt;- vismodel(flowers, visual = &#39;apis&#39;, qcatch = &#39;fi&#39;, scale = 10000) tri.flowers &lt;- colspace(vis.flowers, space = &#39;tri&#39;) head(tri.flowers) ## s m l x y ## Goodenia_heterophylla 0.2882383 0.3587254 0.3530363 -0.004022828 -0.05522995 ## Goodenia_geniculata 0.2475326 0.3549832 0.3974842 0.030052720 -0.10508396 ## Goodenia_gracilis 0.1373117 0.3125304 0.5501579 0.168028001 -0.24007647 ## Xyris_operculata 0.2395035 0.3729820 0.3875145 0.010275990 -0.11491764 ## Eucalyptus_sp 0.2760091 0.3548096 0.3691813 0.010162377 -0.07020755 ## Faradaya_splendida 0.2654951 0.3431266 0.3913783 0.034119147 -0.08308452 ## h.theta r.vec lum ## Goodenia_heterophylla -1.6435057 0.05537626 NA ## Goodenia_geniculata -1.2922439 0.10929687 NA ## Goodenia_gracilis -0.9601417 0.29303604 NA ## Xyris_operculata -1.4816131 0.11537616 NA ## Eucalyptus_sp -1.4270471 0.07093922 NA ## Faradaya_splendida -1.1811377 0.08981733 NA As in the case of our dichromat, the output contains relative photoreceptor stimulations, coordinates in the Maxwell triangle, as well as the ‘hue angle’ h.theta and distance from the origin (r.vec). plot(tri.flowers, pch = 21, bg = spec2rgb(flowers)) Figure 3.8: Floral reflectance in a Maxwell triangle, considering a honeybee visual system. Finally, we’ll draw on the blue tit’s visual system to model our floral reflectance spectra in a tetrahedral space, again using log-transformed quantum catches and assuming bright viewing conditions. vis.flowers &lt;- vismodel(flowers, visual = &quot;bluetit&quot;, qcatch = &quot;fi&quot;, scale = 10000) tetra.flowers &lt;- colspace(vis.flowers, space = &quot;tcs&quot;) head(tetra.flowers) ## u s m l u.r ## Goodenia_heterophylla 0.2274310 0.2659669 0.2524170 0.2541851 -0.02256897 ## Goodenia_geniculata 0.1625182 0.2721621 0.2828016 0.2825182 -0.08748184 ## Goodenia_gracilis 0.0428552 0.2443091 0.3504414 0.3623943 -0.20714480 ## Xyris_operculata 0.1766234 0.2709785 0.2642637 0.2881344 -0.07337659 ## Eucalyptus_sp 0.2118481 0.2609468 0.2637023 0.2635028 -0.03815190 ## Faradaya_splendida 0.1844183 0.2557660 0.2786393 0.2811764 -0.06558169 ## s.r m.r l.r x ## Goodenia_heterophylla 0.015966893 0.002417012 0.004185066 -0.007214866 ## Goodenia_geniculata 0.022162064 0.032801599 0.032518179 0.006341799 ## Goodenia_gracilis -0.005690920 0.100441373 0.112394348 0.072312163 ## Xyris_operculata 0.020978454 0.014263689 0.038134446 0.010505857 ## Eucalyptus_sp 0.010946788 0.013702317 0.013502794 0.001565228 ## Faradaya_splendida 0.005765955 0.028639328 0.031176408 0.015560661 ## y z h.theta h.phi r.vec ## Goodenia_heterophylla -0.005415708 -0.02256897 -2.4976873 -1.190529 0.02430520 ## Goodenia_geniculata 0.003861848 -0.08748184 0.5469755 -1.486123 0.08779638 ## Goodenia_gracilis 0.033297418 -0.20714480 0.4315247 -1.203879 0.22191605 ## Xyris_operculata -0.010813615 -0.07337659 -0.7998327 -1.368146 0.07490949 ## Eucalyptus_sp 0.001044768 -0.03815190 0.5885699 -1.521510 0.03819828 ## Faradaya_splendida 0.007189965 -0.06558169 0.4328380 -1.315140 0.06778487 ## r.max r.achieved lum ## Goodenia_heterophylla 0.2692325 0.09027589 NA ## Goodenia_geniculata 0.2508989 0.34992737 NA ## Goodenia_gracilis 0.2678272 0.82857920 NA ## Xyris_operculata 0.2552227 0.29350636 NA ## Eucalyptus_sp 0.2503039 0.15260760 NA ## Faradaya_splendida 0.2583986 0.26232676 NA Tetrahedral data (via colspace(space = 'tcs')) may be plotted in a standard static tetrahedron by using plot(), or can be visualised as part of an interactive tetrahedron by using tcsplot() with the accessory functions tcspoints() and tcsvol() for adding points and convex hulls, respectively. As with other colourspace plots there are a number of associated graphical options, though the theta and phi arguments are particularly useful in this case, as they control the orientation (in degrees) of the tetrahedron in the xy and yz planes, respectively. When plotting the tetrahedral colourspace, one can also force perspective by changing the size of points relative to their distance from the plane of observation, using the arguments perspective = TRUE and controlling the size range with the range argument. Several other options control the appearance of this plot, you can check these using ?plot.colspace or ?tetraplot plot(tetra.flowers, pch = 21, bg = spec2rgb(flowers), perspective = TRUE, range = c(1, 2), cex = 0.5) Figure 3.9: Flowers in a tetrahedral colourspace modelled using the visual phenotype of the blue tit. Point size is used to force perspective Two additional functions may help with tetrahedral colourspace plotting: axistetra() function can be used to draw arrows showing the direction and magnitude of distortion of x, y and z in the tetrahedral plot. legendtetra() allows you to add a legend to a plot. plot(tetra.flowers, pch = 21, bg = spec2rgb(flowers)) axistetra(x = 0, y = 1.8) plot(tetra.flowers, theta = 110, phi = 10, pch = 21, bg = spec2rgb(flowers)) axistetra(x = 0, y = 1.8) Figure 3.10: Flowers in a tetrahedral colourspace, with varied orientations and perspectives, modelled using the visual phenotype of the blue tit. For tetrahedral models, another plotting option available is projplot, which projects colour points in the surface of a sphere encompassing the tetrahedron. This plot is particularly useful to see differences in hue. projplot(tetra.flowers, pch = 20, col = spec2rgb(flowers)) Figure 3.11: Projection plot from a tetrahedral colour space. Finally, a useful function for tri- and tetrahedral models is voloverlap(), which calculates the overlap in tri- or tetrahedral colour volume between two sets of points. This can be useful to explore whether different species occupy similar (overlapping) or different (non- overlapping) “sensory niches,” or to test for mimetism, dichromatism, etc. (Stoddard and Stevens 2011). To show this function, we will use the sicalis dataset, which includes measurements from the crown (C), throat (T) and breast (B) of seven stripe-tailed yellow finches (Sicalis citrina). data(sicalis) We will use this dataset to test for the overlap between the volume determined by the measurements of those body parts from multiple individuals in the tetrahedral colourspace (note the option plot for plotting of the volumes): tcs.sicalis.C &lt;- subset(colspace(vismodel(sicalis)), &quot;C&quot;) tcs.sicalis.T &lt;- subset(colspace(vismodel(sicalis)), &quot;T&quot;) tcs.sicalis.B &lt;- subset(colspace(vismodel(sicalis)), &quot;B&quot;) voloverlap(tcs.sicalis.T, tcs.sicalis.B, plot = TRUE) ## vol1 vol2 overlapvol vsmallest vboth ## 1 5.183721e-06 6.281511e-06 6.904074e-07 0.1331876 0.06407598 voloverlap(tcs.sicalis.T, tcs.sicalis.C, plot = TRUE) ## vol1 vol2 overlapvol vsmallest vboth ## 1 5.183721e-06 4.739152e-06 0 0 0 The function voloverlap() gives the volume (\\(V\\)) of the convex hull delimited by the overlap between the two original volumes, and two proportions are calculated from that: \\[\\text{vsmallest} = V_{overlap} / \\min(V_A, V_B)\\] and \\[\\text{vboth} = V_{overlap} / (V_A + V_B)\\]. Thus, if one of the volumes is entirely contained in the other, vsmallest will equal 1. So we can clearly see that there is overlap between the throat and breast colours (of about 6%), but not between the throat and the crown colours (Figures above). Summary variables for groups of points Another advantage of colourspace models is that they allow for the calculation of useful summary statistics of groups of points, such as the centroid of the points, the total volume occupied, the mean and variance of hue span and the mean saturation. In pavo, the result of a colspace() call is an object of class colspace, and thus these summary statistics can be calculated simply by calling summary. Note that the summary call can also take a by vector of group identities, so that the variables are calculated for each group separately: summary(tetra.flowers) ## Colorspace &amp; visual model options: ## * Colorspace: tcs ## * Quantal catch: fi ## * Visual system, chromatic: bluetit ## * Visual system, achromatic: none ## * Illuminant: ideal, scale = 10000 (von Kries colour correction not applied) ## * Background: ideal ## * Relative: TRUE ## * Max possible chromatic volume: NA ## &#39;avalue&#39; automatically set to 1.9861e-01 ## centroid.u centroid.s centroid.m centroid.l c.vol rel.c.vol ## all.points 0.1948478 0.2554421 0.2704411 0.279269 0.0002510915 0.001159742 ## colspan.m colspan.v huedisp.m huedisp.v mean.ra max.ra ## all.points 0.05706825 0.001682224 0.6413439 0.3157949 0.2428508 0.8285792 ## a.vol ## all.points 0.0001723672 It is important to highlight that oftentimes, the properties of the visual system will make it impossible to reach the entirety of the Maxwell triangle space (or tetrahedron for tetrachromatic viewers). You can view the maximum gamut of a given viewer by switching the gamut argument to TRUE in plot.colspace(): vis.flowers &lt;- vismodel(flowers, visual = &quot;ctenophorus&quot;) tri.flowers &lt;- colspace(vis.flowers) plot(tri.flowers, pch = 21, bg = spec2rgb(flowers), gamut = TRUE) This information is also available in the summary, in the “Max possible chromatic volume” line: summary(tri.flowers) ## Colorspace &amp; visual model options: ## * Colorspace: trispace ## * Quantal catch: Qi ## * Visual system, chromatic: ctenophorus ## * Visual system, achromatic: none ## * Illuminant: ideal, scale = 1 (von Kries colour correction not applied) ## * Background: ideal ## * Relative: TRUE ## * Max possible chromatic volume: 0.4729301 ## s m l x ## Min. :0.02084 Min. :0.2318 Min. :0.2066 Min. :-0.09877 ## 1st Qu.:0.18617 1st Qu.:0.3005 1st Qu.:0.3806 1st Qu.: 0.02242 ## Median :0.23206 Median :0.3452 Median :0.4180 Median : 0.05899 ## Mean :0.23206 Mean :0.3225 Mean :0.4454 Mean : 0.08689 ## 3rd Qu.:0.29330 3rd Qu.:0.3513 3rd Qu.:0.5039 3rd Qu.: 0.12564 ## Max. :0.44720 Max. :0.3660 Max. :0.7474 Max. : 0.36460 ## y h.theta r.vec lum ## Min. :-0.38273 Min. :-1.9491 Min. :0.02264 Mode:logical ## 1st Qu.:-0.18023 1st Qu.:-1.2269 1st Qu.:0.08330 NA&#39;s:36 ## Median :-0.12404 Median :-0.9590 Median :0.13917 ## Mean :-0.12404 Mean :-0.5767 Mean :0.17858 ## 3rd Qu.:-0.04903 3rd Qu.:-0.7747 3rd Qu.:0.24002 ## Max. : 0.13946 Max. : 2.6273 Max. :0.52860 3.1.4.6.2 The Colour Hexagon The hexagon colour space of Chittka (1992) is a generalised colour-opponent model of hymenopteran vision that has found extremely broad use, particularly in studies of bee-flower interactions. It’s also often broadly applied across hymenopteran species, because the photopigments underlying trichromatic vision in Hymenoptera appear to be quite conserved (Briscoe and Chittka 2001). What’s particularly useful is that colour distances within the hexagon have been extensively validated against behaviour, and thus offer a relatively reliable measure of perceptual distance. In the hexagon, photoreceptor quantum catches are typically hyperbolically transformed (and pavo will return a warning if the transform is not selected), and vonkries correction is often used used to model photoreceptor adaptation to a vegetation background. This can all now be specified in vismodel(). including the optional use of a ‘green’ vegetation background. Note that although this is a colourspace model, we specific relative = FALSE to return unnormalised quantum catches, as required for the model. vis.flowers &lt;- vismodel(flowers, visual = &#39;apis&#39;, qcatch = &#39;Ei&#39;, relative = FALSE, vonkries = TRUE, achromatic = &#39;l&#39;, bkg = &#39;green&#39;) We can then apply the hexagon model in colspace, which will convert our photoreceptor ‘excitation values’ to coordinates in the hexagon according to: \\[ \\begin{split} x &amp;= \\frac{\\sqrt{3}}{2(E_g + E_{uv})}\\\\ y &amp;= E_b - 0.5(E_{uv} + E_g) \\end{split} \\] hex.flowers &lt;- colspace(vis.flowers, space = &#39;hexagon&#39;) head(hex.flowers) ## s m l x y ## Goodenia_heterophylla 0.56572097 0.8237141 0.7053057 0.1208839 0.1882007 ## Goodenia_geniculata 0.35761236 0.8176153 0.8670134 0.4411542 0.2053024 ## Goodenia_gracilis 0.01888788 0.1622766 0.7810589 0.6600594 -0.2376968 ## Xyris_operculata 0.21080752 0.7345122 0.6796464 0.4060263 0.2892853 ## Eucalyptus_sp 0.55622758 0.8515289 0.8208038 0.2291297 0.1630132 ## Faradaya_splendida 0.45855056 0.7828905 0.8565895 0.3447118 0.1253205 ## h.theta r.vec sec.fine sec.coarse lum ## Goodenia_heterophylla 32.71320 0.2236793 30 bluegreen 0.1680153 ## Goodenia_geniculata 65.04388 0.4865862 60 bluegreen 0.3548825 ## Goodenia_gracilis 109.80467 0.7015541 100 green 0.2313678 ## Xyris_operculata 54.53092 0.4985412 50 bluegreen 0.1518319 ## Eucalyptus_sp 54.57024 0.2812005 50 bluegreen 0.2787543 ## Faradaya_splendida 70.02119 0.3667853 70 bluegreen 0.3351008 Again, the output includes the photoreceptor excitation values for short- medium- and long-wave sensitive photoreceptors, x and y coordinates, and measures of hue and saturation for each stimulus. The hexagon model also outputs two additional measures of of subjective ‘bee-hue’; sec.fine and sec.coarse. sec.fine describes the location of stimuli within one of 36 ‘hue sectors’ that are specified by radially dissecting the hexagon in 10-degree increments. sec.coarse follows a similar principle, though here the hexagon is divided into only five ‘bee-hue’ sectors: UV, UV-blue, blue, blue-green, green, and UV-green. These can easily be visualised by specifying sectors = 'coarse or sectors = 'fine' in a call to plot after modelling. plot(hex.flowers, sectors = &#39;coarse&#39;, pch = 21, bg = spec2rgb(flowers)) Figure 3.12: Flowers as modelled in the hymenopteran colour hexagon of Chittka (1992), overlain with coarse bee-hue sectors. 3.1.4.6.3 The Colour Opponent Coding (COC) Space The colour opponent coding (coc) space is an earlier hymenopteran visual model (Backhaus 1991) which, although now seldom used in favour of the hexagon, may prove useful for comparative work. While the initial estimation of photoreceptor excitation is similar to that in the hexagon, the coc subsequently specifies A and B coordinates based on empirically-derived weights for the output from each photoreceptor: \\[ \\begin{split} A &amp;= -9.86E_u + 7.70E_b + 2.16E_g\\\\ B &amp;= -5.17E_u + 20.25E_b - 15.08E_g \\end{split} \\] Where \\(E_i\\) is the excitation value (hyperbolic-transformed quantum catch) in photoreceptor \\(i\\). vis.flowers &lt;- vismodel(flowers, visual = &quot;apis&quot;, qcatch = &quot;Ei&quot;, relative = FALSE, vonkries = TRUE, bkg = &quot;green&quot;) coc.flowers &lt;- colspace(vis.flowers, space = &quot;coc&quot;) head(coc.flowers) ## s m l x y ## Goodenia_heterophylla 0.56572097 0.8237141 0.7053057 2.288050 3.1194224 ## Goodenia_geniculata 0.35761236 0.8176153 0.8670134 4.642329 1.6332926 ## Goodenia_gracilis 0.01888788 0.1622766 0.7810589 2.750382 -8.5899171 ## Xyris_operculata 0.21080752 0.7345122 0.6796464 5.045218 3.5349309 ## Eucalyptus_sp 0.55622758 0.8515289 0.8208038 2.845304 1.9900420 ## Faradaya_splendida 0.45855056 0.7828905 0.8565895 3.357182 0.5654568 ## r.vec lum ## Goodenia_heterophylla 5.407473 NA ## Goodenia_geniculata 6.275622 NA ## Goodenia_gracilis 11.340299 NA ## Xyris_operculata 8.580149 NA ## Eucalyptus_sp 4.835346 NA ## Faradaya_splendida 3.922638 NA The A and B coordinates are designated x and y in the output of coc for consistency, and while the model includes a measure of saturation in r.vec, it contains no associated measure of hue. plot(coc.flowers, pch = 21, bg = spec2rgb(flowers), yaxt = &quot;n&quot;) Figure 3.13: Flowers in the colour-opponent-coding space of Backhaus (1991), as modelling according to the honeybee. 3.1.4.6.4 CIE Spaces The CIE (International Commission on Illumination) colourspaces are a suite of models of human colour vision and perception. pavo 1.0 now includes two of the most commonly used: the foundational 1931 CIE XYZ space, and the more modern, perceptually calibrated CIE LAB space and its cylindrical CIE LCh transformation. Tristimulus values in XYZ space are calculated as: \\[ \\begin{split} X &amp;= k\\int_{300}^{700}{R(\\lambda)I(\\lambda)\\bar{x}(\\lambda)\\,d\\lambda}\\\\ Y &amp;= k\\int_{300}^{700}{R(\\lambda)I(\\lambda)\\bar{y}(\\lambda)\\,d\\lambda}\\\\ Z &amp;= k\\int_{300}^{700}{R(\\lambda)I(\\lambda)\\bar{z}(\\lambda)\\,d\\lambda} \\end{split} \\] where x, y, and z are the trichromatic colour matching functions for a ‘standard colourimetric viewer.’ These functions are designed to describe an average human’s chromatic response within a specified viewing arc in the fovea (to account for the uneven distribution of cones across eye). pavo includes both the CIE 2-degree and the modern 10-degree standard observer, which can be selected in the visual option in the vismodel function. In these equations, k is the normalising factor \\[k = \\frac{100}{\\int_{300}^{700}{I(\\lambda)\\bar{y}(\\lambda)\\,d\\lambda}}\\] and the chromaticity coordinates of stimuli are calculated as \\[ \\begin{split} x &amp;= \\frac{X}{X + Y + Z}\\\\ y &amp;= \\frac{Y}{X + Y + Z}\\\\ z &amp;= \\frac{Z}{X + Y + Z} = 1 - x - y \\end{split} \\] For modelling in both XYZ and LAB spaces, here we’ll use the CIE 10-degree standard observer, and assume a D65 ‘standard daylight’ illuminant. Again, although they are colourspace models, we need to set relative = FALSE to return raw quantum catch estimates, vonkries = TRUE to account for the required normalising factor (as above), and achromatic = 'none' since there is no applicable way to estimate luminance in the CIE models. As with all models that have particular requirements, vismodel() will output warnings and/or errors if unusual or non-standard arguments are specified. vis.flowers &lt;- vismodel(flowers, visual = &#39;cie10&#39;, illum = &#39;D65&#39;, vonkries = TRUE, relative = FALSE, achromatic = &#39;none&#39;) ciexyz.flowers &lt;- colspace(vis.flowers, space = &#39;ciexyz&#39;) head(ciexyz.flowers) ## X Y Z x y ## Goodenia_heterophylla 0.2095846 0.2074402 0.30060475 0.2920513 0.2890630 ## Goodenia_geniculata 0.6415362 0.6751982 0.42423209 0.3684943 0.3878295 ## Goodenia_gracilis 0.5027874 0.4538738 0.01742707 0.5161620 0.4659473 ## Xyris_operculata 0.2847275 0.2325247 0.22131809 0.3855117 0.3148309 ## Eucalyptus_sp 0.4421178 0.4469747 0.40173521 0.3425072 0.3462699 ## Faradaya_splendida 0.6545883 0.6532237 0.28855528 0.4100487 0.4091939 ## z ## Goodenia_heterophylla 0.41888569 ## Goodenia_geniculata 0.24367620 ## Goodenia_gracilis 0.01789065 ## Xyris_operculata 0.29965743 ## Eucalyptus_sp 0.31122295 ## Faradaya_splendida 0.18075745 The output is simply the tristimulus values and chromaticity coordinates of stimuli, and we can visualise our results (along with a line connecting monochromatic loci, by default) by calling plot(ciexyz.flowers, pch = 21, bg = spec2rgb(flowers)) Figure 3.14: Floral reflectance in the CIEXYZ human visual model. Note that this space is not perceptually calibrated, so we cannot make inferences about the similarity or differences of colours based on their relative location. The Lab space is a more recent development, and is a colour-opponent model that attempts to mimic the nonlinear responses of the human eye. The Lab space is also calibrated (unlike the XYZ space) such that Euclidean distances between points represent relative perceptual distances. This means that two stimuli that are farther apart in Lab space should be perceived as more different than two closer points. As the name suggests, the dimensions of the Lab space are Lightness (i.e. subjective brightness), along with two colour-opponent dimensions designated a and b. The colspace() function, when space = cielab, simply converts points from the XYZ model according to: $$ \\[\\begin{split} L &amp;=\\begin{cases} 116\\left(\\frac{Y}{Y_n}\\right)^\\frac{1}{3} &amp; \\text{if } \\frac{Y}{Y_n} &gt; 0.008856 \\\\ 903.3\\left(\\frac{Y}{Y_n}\\right) &amp; \\text{if } \\frac{Y}{Y_n} \\leq 0.008856 \\end{cases}\\\\ a &amp;= 500\\left(f\\left(\\frac{X}{X_n}\\right) - f\\left(\\frac{Y}{Y_n}\\right)\\right)\\\\ b &amp;= 500\\left(f\\left(\\frac{Y}{Y_n}\\right) - f\\left(\\frac{Z}{Z_n}\\right)\\right) \\end{split}\\] $$ where \\[ f(x)=\\begin{cases} x^\\frac{1}{3} &amp; \\text{if } x &gt; 0.008856 \\\\ 7.787x + \\frac{4}{29} &amp; \\text{if } x \\leq 0.008856 \\end{cases} \\] Here, \\(X_n, Y_n, Z_n\\) are neutral point values to model visual adaptation, calculated as: \\[ \\begin{split} X_n &amp;= \\int_{300}^{700}{R_n(\\lambda)I(\\lambda)\\bar{x}(\\lambda)\\,d\\lambda}\\\\ Y_n &amp;= \\int_{300}^{700}{R_n(\\lambda)I(\\lambda)\\bar{y}(\\lambda)\\,d\\lambda}\\\\ Z_n &amp;= \\int_{300}^{700}{R_n(\\lambda)I(\\lambda)\\bar{z}(\\lambda)\\,d\\lambda} \\end{split} \\] when \\(R_n(\\lambda)\\) is a perfect diffuse reflector (i.e. 1). cielab.flowers &lt;- colspace(vis.flowers, space = &#39;cielab&#39;) head(cielab.flowers) ## X Y Z L a ## Goodenia_heterophylla 0.2095846 0.2074402 0.30060475 16.75107 3.110872 ## Goodenia_geniculata 0.6415362 0.6751982 0.42423209 54.52316 -4.478971 ## Goodenia_gracilis 0.5027874 0.4538738 0.01742707 36.65092 22.697331 ## Xyris_operculata 0.2847275 0.2325247 0.22131809 18.77668 21.382120 ## Eucalyptus_sp 0.4421178 0.4469747 0.40173521 36.09381 3.297259 ## Faradaya_splendida 0.6545883 0.6532237 0.28855528 52.74869 7.859790 ## b ## Goodenia_heterophylla -18.616834 ## Goodenia_geniculata 26.973109 ## Goodenia_gracilis 60.437370 ## Xyris_operculata -2.596506 ## Eucalyptus_sp -1.246816 ## Faradaya_splendida 45.351679 Our output now contains the tristimulus XYZ values, as well as their Lab counterparts, which are coordinates in the Lab space. These can also be visualised in three-dimensional Lab space by calling plot: plot(cielab.flowers, pch = 21, bg = spec2rgb(flowers)) Figure 3.15: Floral reflectance spectra represented in the CIELab model of human colour sensation. 3.1.4.6.5 Categorical Fly Colourspace The categorical colour vision model of Troje (1993) is a model of dipteran vision, based on behavioural data from the blowfly Lucilia sp. It assumes the involvement of all four dipteran photoreceptor classes (R7 &amp; R8 ‘pale’ and ‘yellow’ subtypes), and further posits that colour vision is based on two specific opponent mechanisms (R7p - R8p, and R7y - R8y). The model assumes that all colours are perceptually grouped into one of four colour categories, and that flies are unable to distinguish between colours that fall within the same category. We’ll use the visual systems of the muscoid fly Musca domestica, and will begin by estimating linear (i.e. untransformed) quantum catches for each of the four photoreceptors. vis.flowers &lt;- vismodel(flowers, qcatch = &#39;Qi&#39;, visual = &#39;musca&#39;, achromatic = &#39;none&#39;, relative = TRUE) Our call to colspace() will then simply estimate the location of stimuli in the categorical space as the difference in relative stimulation between ‘pale’ (R7p - R8p) and ‘yellow’ (R7y - R8y) photoreceptor pairs: \\[ \\begin{split} x &amp;= R7_p - R8_p\\\\ y &amp;= R7_y - R8_y \\end{split} \\] cat.flowers &lt;- colspace(vis.flowers, space = &#39;categorical&#39;) head(cat.flowers) ## R7p R7y R8p R8y x ## Goodenia_heterophylla 0.05387616 0.18710662 0.4335986 0.3254187 -0.3797224 ## Goodenia_geniculata 0.02080098 0.08276030 0.3737592 0.5226795 -0.3529583 ## Goodenia_gracilis 0.01153130 0.02501417 0.1420049 0.8214496 -0.1304736 ## Xyris_operculata 0.01270353 0.12523419 0.4488377 0.4132246 -0.4361342 ## Eucalyptus_sp 0.03461949 0.14207848 0.3977208 0.4255812 -0.3631013 ## Faradaya_splendida 0.03599953 0.09188560 0.3129195 0.5591953 -0.2769200 ## y category r.vec h.theta lum ## Goodenia_heterophylla -0.1383120 p-y- 0.4041279 -2.792284 NA ## Goodenia_geniculata -0.4399192 p-y- 0.5640110 -2.246954 NA ## Goodenia_gracilis -0.7964355 p-y- 0.8070519 -1.733176 NA ## Xyris_operculata -0.2879904 p-y- 0.5226390 -2.557993 NA ## Eucalyptus_sp -0.2835027 p-y- 0.4606695 -2.478681 NA ## Faradaya_splendida -0.4673097 p-y- 0.5431971 -2.105745 NA And it is simply the signs of these differences that define the four possible fly-colour categories (p+y+, p-y+, p+y-, p-y-), which we can see in the associated plot. plot(cat.flowers, pch = 21, bg = spec2rgb(flowers)) Figure 3.16: Flowers in the categorical colourspace of Troje (1993). 3.1.4.6.6 Segment Classification The segment classification analysis (Endler 1990) does not assume any particular visual system, but instead tries to classify colours in a manner that captures common properties of many vertebrate (and some invertebrate) visual systems. In essence, it breaks down the reflectance spectrum region of interest into four equally-spaced regions, measuring the relative signal along those regions. This approximates a tetrachromatic system with ultraviolet, short, medium, and long-wavelength sensitive photoreceptors. Though somewhat simplistic, this model captures many of the properties of other, more complex visual models, but without many of the additional assumptions these make. It also provides results in a fairly intuitive colour space, in which the angle corresponds to hue and the distance from the centre corresponds to chroma (Figure below; in fact, variables S5 and H4 from summary.rspec() are calculated from these relative segments). Note that, while a segment analysis ranging from 300 or 400 nm to 700 nm corresponds quite closely to the human visual system colour wheel, any wavelength range can be analysed in this way, returning a 360° hue space delimited by the range used. The segment differences or “opponents” are calculated as: \\[ \\begin{split} LM &amp;= \\frac{ R_\\lambda \\sum_{\\lambda={Q4}} R_\\lambda - \\sum_{\\lambda={Q2}} R_\\lambda }{\\sum_{\\lambda={min}}^{max}R_\\lambda}\\\\ MS &amp;= \\frac{ R_\\lambda \\sum_{\\lambda={Q3}} R_\\lambda - \\sum_{\\lambda={Q1}} R_\\lambda }{\\sum_{\\lambda={min}}^{max}R_\\lambda} \\end{split} \\] Where \\(Qi\\) represent the interquantile distances (e.g. \\(Q1=ultraviolet\\), \\(Q2=blue\\), \\(Q3=green\\) and \\(Q4=red\\)) The segment classification model is obtained through the colspace() argument space = 'segment', following initial modelling with vismodel(). The example below uses idealized reflectance spectra to illustrate how the avian colour space defined from the segment classification maps to the human colour wheel: fakedata1 &lt;- vapply( seq(100, 500, by = 20), function(x) rowSums(cbind( dnorm(300:700, x, 30), dnorm(300:700, x + 400, 30) )), numeric(401) ) # creating idealized specs with varying saturation fakedata2 &lt;- vapply( c(500, 300, 150, 105, 75, 55, 40, 30), function(x) dnorm(300:700, 550, x), numeric(401) ) fakedata1 &lt;- as.rspec(data.frame(wl = 300:700, fakedata1)) ## wavelengths found in column 1 fakedata1 &lt;- procspec(fakedata1, &quot;max&quot;) ## processing options applied: ## Scaling spectra to a maximum value of 1 fakedata2 &lt;- as.rspec(data.frame(wl = 300:700, fakedata2)) ## wavelengths found in column 1 fakedata2 &lt;- procspec(fakedata2, &quot;sum&quot;) ## processing options applied: ## Scaling spectra to a total area of 1 fakedata2 &lt;- procspec(fakedata2, &quot;min&quot;) ## processing options applied: ## Scaling spectra to a minimum value of zero # converting reflectance to percentage fakedata1[, -1] &lt;- fakedata1[, -1] * 100 fakedata2[, -1] &lt;- fakedata2[, -1] / max(fakedata2[, -1]) * 100 # combining and converting to rspec fakedata.c &lt;- data.frame(wl = 300:700, fakedata1[, -1], fakedata2[, -1]) fakedata.c &lt;- as.rspec(fakedata.c) ## wavelengths found in column 1 # segment classification analysis seg.vis &lt;- vismodel(fakedata.c, visual = &quot;segment&quot;, achromatic = &quot;all&quot;) seg.fdc &lt;- colspace(seg.vis, space = &quot;segment&quot;) # plot results plot(seg.fdc, col = spec2rgb(fakedata.c)) Figure 3.17: Idealized reflectance spectra and their projection on the axes of segment classification 3.1.4.6.7 Colourspace Distances with coldist Under the colour space framework, colour distances can be calculated simply as Euclidean distances of the relative cone stimulation data, either log-transformed or not, depending on how it was defined. However, these distances cannot be interpreted in terms of JNDs, since no receptor noise is incorporated in the model. Euclidean distances can be computed in R using the coldist() function on the colspace() output: head(coldist(tetra.flowers)) ## Quantum catch are relative, distances may not be meaningfulFALSE ## Calculating unweighted Euclidean distances ## patch1 patch2 dS dL ## 1 Goodenia_heterophylla Goodenia_geniculata 0.06695922 NA ## 2 Goodenia_heterophylla Goodenia_gracilis 0.20467411 NA ## 3 Goodenia_heterophylla Xyris_operculata 0.05407934 NA ## 4 Goodenia_heterophylla Eucalyptus_sp 0.01901724 NA ## 5 Goodenia_heterophylla Faradaya_splendida 0.05027645 NA ## 6 Goodenia_heterophylla Gaultheria_hispida 0.03897671 NA Specialised colourspace models such as the colour-hexagon, coc space, CIELab and CIELCh models have their own distance measures, which are returned be default when run through coldist(). Be sure to read the ?coldist documentation, and the original publications, to understand what is being returned. As an example, if we run the results of colour-hexagon modelling through coldist(): # Model flower colours according to a honeybee vis.flowers &lt;- vismodel(flowers, visual = &quot;apis&quot;, qcatch = &quot;Ei&quot;, relative = FALSE, vonkries = TRUE, achromatic = &quot;l&quot;, bkg = &quot;green&quot;) hex.flowers &lt;- colspace(vis.flowers, space = &quot;hexagon&quot;) # Estimate colour distances. No need to specify relative receptor densities, noise etc., # which only apply in the case of receptor-noise modelling dist.flowers &lt;- coldist(hex.flowers) ## Calculating unweighted Euclidean distances head(dist.flowers) ## patch1 patch2 dS dL ## 1 Goodenia_heterophylla Goodenia_geniculata 0.3207265 NA ## 2 Goodenia_heterophylla Goodenia_gracilis 0.6870945 NA ## 3 Goodenia_heterophylla Xyris_operculata 0.3025298 NA ## 4 Goodenia_heterophylla Eucalyptus_sp 0.1111375 NA ## 5 Goodenia_heterophylla Faradaya_splendida 0.2324927 NA ## 6 Goodenia_heterophylla Gaultheria_hispida 0.2280836 NA the chromatic contrasts dS and achromatic contrasts dL are expressed as Euclidean distances in the hexagon, known as ‘hexagon units’ (Chittka 1992). If we had instead used the colour-opponent coding space the units would have been city-bloc distances, while in the CIELab model the distances would be derived from the CIE colour-distance formula (2000). 3.1.4.6.8 Distances in N-Dimensions The coldist() function is no longer limited to di-, tri- or tetrachromatic visual systems. The function has been generalised, and can now calculate colour distances for n-dimensional visual phenotypes. This means there is no limit on the dimensionality of visual systems that may be input, which may prove useful for modelling nature’s extremes (e.g. butterflies, mantis shrimp) or for simulation-based work. Naturally, since these calculations aren’t largely implemented elsewhere, we recommend caution and validation of results prior to publication. # Create an arbitrary visual phenotype with 10 photoreceptors fakemantisshrimp &lt;- sensmodel(c(325, 350, 400, 425, 450, 500, 550, 600, 650, 700), beta = FALSE, integrate = FALSE) # Convert to percentages, just to colour the plot fakemantisshrimp.colours &lt;- fakemantisshrimp * 100 fakemantisshrimp.colours[, &quot;wl&quot;] &lt;- fakemantisshrimp[, &quot;wl&quot;] plot(fakemantisshrimp, col = spec2rgb(fakemantisshrimp.colours), lwd = 2, ylab = &quot;Absorbance&quot;) Figure 3.18: Visual system of a pretend mantis shrimp with 10 cones # Run visual model and calculate colour distances vm.fms &lt;- vismodel(flowers, visual = fakemantisshrimp, relative = FALSE, achromatic = FALSE) JND.fms &lt;- coldist(vm.fms, n = c(1, 1, 2, 2, 3, 3, 4, 4, 5, 5)) ## Calculating noise-weighted Euclidean distances head(JND.fms) ## patch1 patch2 dS dL ## 1 Goodenia_heterophylla Goodenia_geniculata 16.297557 NA ## 2 Goodenia_heterophylla Goodenia_gracilis 48.390309 NA ## 3 Goodenia_heterophylla Xyris_operculata 30.760482 NA ## 4 Goodenia_heterophylla Eucalyptus_sp 6.044184 NA ## 5 Goodenia_heterophylla Faradaya_splendida 15.901435 NA ## 6 Goodenia_heterophylla Gaultheria_hispida 11.188246 NA 3.2 Analysing Spatial Data pavo now allows for the combined analysis of spectral data and spatial data. Note that ‘spatial’ data of course include images, but may also draw on spatially-sampled spectra, as explored below. Thus while much of the below deals with image-based processing and analysis, images are not necessary for many spatial analyses and indeed may perform worse than spectrally-based analyses in some cases. Further, image data should seldom be used without input from spectral measurements. Even in the simple butterfly example below, users should first validate the presence and number of discrete colours in a patch via spectral measurement and visual modelling (i.e. the ‘spectral’ information), which is then augmented by image-based clustering of these a priori identified patches to extract the ‘spatial’ information. Using uncalibrated images alone for inferences about colour pattern perception may well yield unreliable results, given the radical differences between human (camera) and non-human animal perception. 3.2.1 Image-based colour classification We first import our images with getimg(), which functions in a similar manner to getspec(). Since we are importing more than one image, we can simply point the function to the folder containing the images, and it will use parallel processing (where possible) to import any jpg, bmp, or png images in the folder. As with the raw spectra, these images are also available at the package repository [here][data-location], but are included in the package installation for convenience. butterflies &lt;- getimg(system.file(&quot;testdata/images/&quot;, package = &#39;pavo&#39;)) ## 2 files found; importing images. The segmentation of RGB images into discrete colour-classes is an useful step on the road to several analyses, and this is carried out in pavo via classify(). The function currently implements k-means clustering which, and offers some flexibility in the way in which it is carried out. In the simplest case, we can specify an image or image(s) as well as the number of discrete colours in each, and allow the k-means clustering algorithm to do its work. Note that the specification of k, the number of discrete colours in an image, is a crucial step to be estimated a priori beforehand, typically through the use of visual modelling to estimate the number of discriminable colours in an ‘objective’ manner. There are a suite of possible ways in which this may be achieved, though, with one detailed below as part of example 2. Since we have two images, with (arguably) four and three colours each, including the white background, we can specify this information using kcols, before visualising the results with summary. The summary function, with plot = TRUE, is also particularly useful for understanding the colour-class labels, or ID’s, assigned to each colour, as well as visualising the accuracy of the classification process, which may be enhanced by specifying strongly-contrasting ‘false’ colours for plotting through the col argument. butterflies_class &lt;- classify(butterflies, kcols = c(4, 3)) ## Image classification in progress... # Note that we could simply feed the list of images to summary, rather than # specifying individual images, and they would progress automatically # with user input. summary(butterflies_class[[2]], plot = TRUE) Figure 3.19: The k-means classified images of our butterflies, along with their identified colour palettes There are other options available, which may be of particular use when the classification process is not producing the results that might be expected. If analysing similar images with homologous colour patterns (e.g. individuals within a species), we could specify a single ‘reference’ image in a list to be initially classified, using refID, with the RGB centres identified in this reference image used as pre-specified cluster centres in subsequent images. This helps to ensure that homologous pattern elements are reliably identified and classified between images. The classify() function also offers an interactive option, via interactive = TRUE, wherein we can interactively click on representative colours within an image (or images individually), with the RGB values then used as cluster centres. This is particularly useful when images are being erroneously classified, since the standard k-means process randomly selects initial centres and so may (by chance) miss smaller patches, or confuse similar colours. By specifying the initial RGB centres interactively, it can be easier for the process to distinguish or ‘pull apart’ colours in such circumstances. Ultimately, there are several combinations of options available during classification, which are also documented in the help file. For our butterflies, for example, we could use any of the following (though some would be very ill-advised): # Automatic classification. butterflies_class &lt;- classify(butterflies, kcols = c(4, 3)) ## Image classification in progress... # Automatic classification using a reference image, identified by name. butterflies_class &lt;- classify(butterflies, refID = &#39;h_melpomene&#39;, kcols = 3) ## Image classification in progress... # Classification using interactively-specified centres for each image, with no # need to specify kcols (since it will be inferred from the numbers of colours selected) butterflies_class &lt;- classify(butterflies, interactive = TRUE) # Classification using interactively-specified centres for the single reference image # (here, the first in the list). We could also specify reference image using it&#39;s name, # as above. butterflies_class &lt;- classify(butterflies, refID = 1, interactive = TRUE) 3.2.2 Adjacency and Boundary Strength Analyses, and Overall Pattern Contrasts The adjacency (Endler 2012) and boundary strength (Endler, Cole, and Kranz 2018) analyses offer a powerful method for quantifying various features of colour pattern geometry. Briefly, the process entails classifying grid-sampled locations within a visual scene into a number of discrete colour classes. This may be achieved using classify() as described above before sampling the now-classified image, and/or by taking grid-sampled reflectance spectra across a visual scene, visually modelling and clustering the results (as per ‘method 1’ in Endler 2012, example below). The column-wise and row-wise colour-class transitions between adjacent points within this grid are then tallied, and from this a suite of summary statistics on pattern structure — from simple colour proportions, through to colour diversity and pattern complexity — are estimated. If the colour ‘distance’ between adjacent colour classes is known, such as might be estimated using spectral data for receptor-noise modelling via vismodel() and coldist(), then this can also be incorporated to derive several measures of the salience of patch boundaries (Endler, Cole, and Kranz 2018). Finally, if estimates of hue, saturation, and/or brightness are known for each discrete colour in a pattern, then these can be included through the hsl argument for general, area-weighted measures of overall pattern contrast (Endler and Mielke 2005). In pavo, this is all carried out through the adjacent() function, which takes several arguments that should be well understood. 3.2.2.1 Example 1 (simple): mounted butterflies We’ll begin with a simple example using mounted butterflies, by first loading and classifying our images in the manner outlined above. For the adjacency analysis proper, we’ll specify a full x-dimension scale of 200 mm using xscale (which could be ignored if we specify scales using procimg()), and a sampling density of 200, for a 200 x 200 grid. Since the white background of our images is fake and of no interest, we will also exclude it by specifying the colour-class ID that corresponds to it (for more complex backgrounds, we could instead use procimg(), as above, and ignore this argument). # Load up our images butterflies &lt;- getimg(system.file(&quot;testdata/images/&quot;, package = &#39;pavo&#39;)) ## 2 files found; importing images. # Automatically classify discrete colour patches (as confirmed by spectral modelling) # using k-means clustering, with values of &#39;k&#39; that have been validated a priori. butterflies_class &lt;- classify(butterflies, kcols = c(4, 3)) ## Image classification in progress... # Run the adjacency analysis, subsampling the image in a 200x200 grid, and excluding # the white background. butterflies_adj &lt;- adjacent(butterflies_class, xscale = 200, xpts = 200, bkgID = 1) # Take a look head(butterflies_adj) ## k N n_off p_1 p_2 p_3 p_4 q_1_1 ## h_melpomene 4 54064 5111 0.5833824 0.3408824 0.0406250 0.03511029 0.5649970 ## papilio 3 63241 4371 0.1995597 0.5609434 0.2394969 NA 0.1726728 ## q_1_2 q_2_2 q_2_3 q_3_3 q_1_4 q_2_4 ## h_melpomene 0.018644569 0.3071175 0.01825614 0.02683856 0.01294762 0.03486608 ## papilio 0.006941699 0.5485682 0.01315602 0.20964248 NA NA ## q_3_4 q_4_4 t_1_2 t_2_3 t_1_4 t_2_4 ## h_melpomene 0.009821693 0.006510802 0.1972217 0.1931129 0.1369595 0.3688124 ## papilio NA NA 0.1004347 0.1903455 NA NA ## t_3_4 q_1_3 t_1_3 m m_r m_c ## h_melpomene 0.1038936 NA NA 0.09395221 0.08779412 0.10011029 ## papilio NA 0.04901883 0.7092199 0.06868910 0.07805031 0.05932789 ## A Sc St Jc Jt B Rt ## h_melpomene 0.8769739 2.176663 4.136277 0.5441657 0.6893795 0.8839757 0.5665327 ## papilio 1.3155754 2.428125 1.820461 0.8093752 0.6068204 0.2150538 0.5493113 ## Rab m_dS s_dS cv_dS m_dL s_dL cv_dL m_hue s_hue var_hue m_sat s_sat ## h_melpomene 1 NA NA NA NA NA NA NA NA NA NA NA ## papilio 1 NA NA NA NA NA NA NA NA NA NA NA ## cv_sat m_lum s_lum cv_lum ## h_melpomene NA NA NA NA ## papilio NA NA NA NA The output is a suite of statistics describing colour pattern structure and geometry in a tidy data frame that, since we fed it a list of images, contains one row for each of our samples. As always, the function’s help file (?adjacent) summarises the meaning of each output variable, and the original references listed therein contain the full discussion. Note that some of the output is NA, which might occur when the focal statistic simply makes no sense for the image in question (such as the transition frequency between colour categories 3 and 4, for an image that contains only 3 colour categories). Others may result when we do not give adjacent() enough information, such as the colour-distances required to calculate the boundary-strength statistics, or the colourmetrics required for overall pattern contrast. If we do give the function this information, we can see that those final variables now contain sensible output. # Create a fake matrix of pairwise colour- and luminance distances between all # colour patten elements, as might be attained through visual modelling of spectral data. distances &lt;- data.frame(c1 = c(1, 1, 2), c2 = c(2, 3, 3), dS = c(10.6, 5.1, 4.4), dL = c(1.1, 2.5, 3.2)) # Take a look distances ## c1 c2 dS dL ## 1 1 2 10.6 1.1 ## 2 1 3 5.1 2.5 ## 3 2 3 4.4 3.2 # And our fake hue angles (in radians), saturation, and luminance values, for each # colour pattern element hsl_vals &lt;- data.frame(patch = 1:3, hue = c(1.2, 2.2, 1.6), lum = c(10, 5, 7), sat = c(3.5, 1.1, 6.3)) # Take a look hsl_vals ## patch hue lum sat ## 1 1 1.2 10 3.5 ## 2 2 2.2 5 1.1 ## 3 3 1.6 7 6.3 # Now feed this information into the adjacency analysis using the &#39;less-colourful&#39; # of our two images, for convenience (though this could be readily extended to # include a list of images along with a list of distances and hsl values) adjacent(butterflies_class[[2]], xscale = 200, xpts = 200, bkgID = 1, coldists = distances, hsl = hsl_vals) ## k N n_off p_1 p_2 p_3 q_1_1 q_1_2 ## papilio 3 63241 4371 0.1995597 0.5609434 0.2394969 0.1726728 0.006941699 ## q_2_2 q_1_3 q_2_3 q_3_3 t_1_2 t_1_3 t_2_3 ## papilio 0.5485682 0.04901883 0.01315602 0.2096425 0.1004347 0.7092199 0.1903455 ## m m_r m_c A Sc St Jc ## papilio 0.0686891 0.07805031 0.05932789 1.315575 2.428125 1.820461 0.8093752 ## Jt B Rt Rab m_dS s_dS cv_dS m_dL ## papilio 0.6068204 0.2150538 0.5493113 1 5.519149 2.56091 0.4640044 2.492633 ## s_dL cv_dL m_hue s_hue var_hue m_sat s_sat ## papilio 0.802252 0.3218492 1.663715 0.4154308 0.0826731 2.824327 2.812416 ## cv_sat m_lum s_lum cv_lum ## papilio 0.9957825 6.476792 2.530441 0.3906936 3.2.2.2 Example 2 (complex): whole visual environments Of course colour patterns are not always so simple, and we may want to analyse the spatial geometry of more complex or subtle scenes. In such cases, it may be preferable to largely forego image-based clustering and classification altogether and instead use spectral data directly in an adjacency-style analysis (as per ‘method 1’ in Endler 2012). One such approach would have us take spectral measurements across a patch in an evenly-spaced grid # Load up our image of a camouflaged lizard lizard &lt;- getimg(system.file(&quot;testdata/images/vig/&quot;, package = &#39;pavo&#39;)) ## 1 files found; importing images. # Take a look at it plot(lizard) # And overlay a simple &#39;sampling grid&#39; that might guide us as to where we should collect # our reflectance measurements. Note that the grid here is likely too coarse to capture the necessary detail, # though the sampling density is something to be closely considered on a case-by-case basis plot(lizard) points(expand.grid(seq(0, dim(lizard)[1], 25), seq(0, dim(lizard)[1], 25)), pch = 16, col = &#39;red&#39;) Figure 3.20: A cryptic lizard, along with a possible sampling grid for spectral measurement. For the sake of this example we’ll simulate 100 reflectance spectra, as though we had collected them following the above grid. We’ll do this by creating four very similar groups of of 25 spectra, which will also allow us to get a sense of how our clustering methods perform. Of course real spectra will be more variable, but the same principles apply. set.seed(12352) # For reprodicubility # Generate some fake spectra that were grid-sampled across our scene fakescene &lt;- cbind( do.call(cbind, lapply(1:25, function(x) dnorm(300:700, runif(1, 320, 330), 20))), do.call(cbind, lapply(1:25, function(x) dnorm(300:700, runif(1, 440, 450), 20))), do.call(cbind, lapply(1:25, function(x) dnorm(300:700, runif(1, 550, 560), 20))), do.call(cbind, lapply(1:25, function(x) dnorm(300:700, runif(1, 650, 660), 20))) ) # Convert them to rspce objects fakescene &lt;- as.rspec(data.frame(wl = 300:700, fakescene)) Now instead of calling cluster() on the image and arbitrarily selecting kcols (which would likely be quite inaccurate due to the complexity of the scene), we can visually model the spectra, calculate the colour-distances between them, and cluster the results into a data-image that can be fed directly into adjacent(). Below we’ll use a centroid-based ‘hartigan’ clustering method via the package NbClust, but there are numerous possible approaches that might be used, which should be closely considered with reference to the original methods’ publications. # Visually model our spectra in a tetrahedral model of the blue tit, specifying # relative = FALSE so that we can estimate noise-calibrated distances. vis.fakescene &lt;- vismodel(fakescene, visual = &#39;bluetit&#39;, relative = FALSE, scale = 10000) # Calculate noise-weighted distances, before converting them to xyz coordinates # in noise-corrected colourspace. jnd.fakescene &lt;- jnd2xyz(coldist(vis.fakescene)) # Create a distance matrix, for clustering jnd.mat &lt;- dist(jnd.fakescene, method = &#39;euclidean&#39;, diag = FALSE) # Zero all distance &lt; 1 (&#39;just noticeable distance&#39;, in this model), which corresponds # to a theoretical threshold of discrimination in the receptor-noise limited # model. jnd.mat[which(jnd.mat &lt; 1)] &lt;- 0 # Load up a library and use k-means clustering to estimate the number of discrete # colours present in our sample. library(NbClust) clust &lt;- NbClust(jnd.fakescene, diss = jnd.mat, distance = NULL, method = &#39;centroid&#39;, index = &#39;hartigan&#39;) clust$Best.nc ## Number_clusters Value_Index ## 4.000 1639.353 This approach has identified four distinct colour patches, as simulated. To be able to feed this information directly in to adjacent() we need to arrange the now-classified spectral data into a xyz data-image matrix, in which x and y coordinates specify the location of the sample in our scene, and the z values at each location specify the colour-class, or group, into which each sample has been classified (an integer). Many clustering packages offers the data’s classification as output in some form, so we can simply rearrange it into our original 10 x 10 sampling matrix before passing it to adjacent(). # Rearrange the data into a colour-classified image matrix, and take a look at it. # Note that is the same structure as the output of &#39;classify()&#39;. mat.fakescene &lt;- matrix(as.numeric(unlist(clust$Best.partition)), 10, 10) head(mat.fakescene) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 1 1 1 2 2 3 3 3 4 4 ## [2,] 1 1 1 2 2 3 3 3 4 4 ## [3,] 1 1 1 2 2 3 3 3 4 4 ## [4,] 1 1 1 2 2 3 3 3 4 4 ## [5,] 1 1 1 2 2 3 3 3 4 4 ## [6,] 1 1 2 2 2 3 3 4 4 4 # Run the adjacency analysis adjacent(mat.fakescene, xscale = 200) ## k N n_off p_1 p_2 p_3 p_4 q_1_1 q_1_2 q_2_2 q_2_3 ## img 4 180 32 0.25 0.25 0.25 0.25 0.2055556 0.06111111 0.2055556 0.05555556 ## q_3_3 q_3_4 q_4_4 t_1_2 t_2_3 t_3_4 m m_r m_c A ## img 0.2055556 0.06111111 0.2055556 0.34375 0.3125 0.34375 0.008 0.015 0.001 15 ## Sc St Jc Jt B Rt Rab m_dS s_dS cv_dS m_dL s_dL cv_dL m_hue ## img 4 2.994152 1 0.4990253 NA NA NA NA NA NA NA NA NA NA ## s_hue var_hue m_sat s_sat cv_sat m_lum s_lum cv_lum ## img NA NA NA NA NA NA NA NA The output reflects several aspects of our simulated dataset, which is reassuring. There are four colour classes (k= 4) or equal proportion (p_x), 180 transitions in total (N, 9 transitions per row/column x 10 rows/columns), and the colour diversity (Sc) equals k, and relative colour diversity (Jc) equals 1, since all colours occur in equal proportions. References "],["spectral-shape-descriptors.html", "Chapter 4 Spectral shape descriptors", " Chapter 4 Spectral shape descriptors tr:hover { background-color: #eee; } This table is adapted from Montgomerie (2006) and lists all spectral descriptors that are computed by the summary function in pavo. Color variable Names used Formula Reference Brightness Total brightness, total reflectance, spectral intensity \\[B_1=B_T=\\int_{\\lambda_{min}}^{\\lambda_{max}} R_i = \\sum_{\\lambda_{min}}^{\\lambda_{max}} R_i\\] Andersson (1999),Andersson et al. (2002),Örnborg et al. (2002),Andersson, Örnborg, and Andersson (1998),Smiseth et al. (2001),Saks, McGraw, and Horak (2003),Pryke, Lawes, and Andersson (2001),Shawkey et al. (2003) Mean brightness \\[B_2=\\frac{\\sum_{\\lambda_{min}}^{\\lambda_{max}} R_i}{n_w}=\\frac{B_1}{n_w}\\] Delhey et al. (2003),Siefferman and Hill (2005) Intensity \\[B_3=R_{max}\\] Andersson (1999),Keyser and Hill (2000),Keyser and Hill (1999) Saturation Chroma, reflectance ratio, spectral purity \\[S_1= \\frac{\\sum_{\\lambda_a}^{\\lambda_b} R_i}{\\sum_{\\lambda_{min}}^{\\lambda_{max}} R_i} = \\frac{\\sum_{\\lambda_a}^{\\lambda_b} R_i}{B_1}\\] Örnborg et al. (2002),Andersson, Örnborg, and Andersson (1998),Smiseth et al. (2001),Siefferman and Hill (2005),Peters et al. (2004),Shawkey et al. (2003) Spectral saturation \\[S_2 = \\frac{R_{max}}{R_{min}}\\] Andersson (1999) Chroma \\[S_3 = \\frac{\\sum_{\\lambda_{R_{max}}-50}^{\\lambda_{R_{max}}+50} R_i}{B_1}\\] Shawkey et al. (2003) Spectral purity \\[S_4 = \\lvert b\\text{max}_{neg}\\lvert\\] Andersson (1999) Chroma \\[S_5=\\sqrt{(B_r-B_g)^2+(B_y-B_b)^2}\\] Saks, McGraw, and Horak (2003) Constrast, amplitude \\[S_6 = R_{max} - R_{min}\\] Keyser and Hill (2000),Keyser and Hill (1999) Spectral saturation \\[S_7 = \\frac{\\left(\\sum_{\\lambda_{320}}^{\\lambda_{R_{mid}}} R_i - \\sum_{\\lambda_{R_{mid}}}^{\\lambda_{700}} R_i\\right)}{B_1}\\] Andersson et al. (2002),Pryke, Lawes, and Andersson (2001) Chroma \\[S_8=\\frac{R_{max}-R_{min}}{B_2}\\] Andersson et al. (2002),Smiseth et al. (2001) Carotenoid chroma \\[S_9=\\frac{R_{\\lambda_{700}}-R_{\\lambda_{450}}}{R_{\\lambda_{700}}}\\] Peters et al. (2004) Peaky chroma \\[S_{10}=\\lvert b\\text{max}_{neg} \\lvert\\frac{R_{max}-R_{min}}{B_2}\\] Örnborg et al. (2002) Hue Hue, peak wavelength, spectral location \\[H_1=\\lambda_{R_{max}}\\] Andersson (1999),Örnborg et al. (2002),Andersson, Örnborg, and Andersson (1998),Delhey et al. (2003),Smiseth et al. (2001),Keyser and Hill (2000),Siefferman and Hill (2005),Shawkey et al. (2003) Hue \\[H_2 = \\lambda_{b\\text{max}_{neg}}\\] Andersson, Örnborg, and Andersson (1998),Smiseth et al. (2001) Hue \\[H_3 = \\lambda_{R_{mid}}\\] Andersson et al. (2002),Smiseth et al. (2001),Pryke, Lawes, and Andersson (2001) Hue \\[H_4 = \\arctan\\left(\\frac{B_y-B_b}{B_r-B_g}\\right)\\] Saks, McGraw, and Horak (2003) Hue \\[H_5 = \\lambda_{b\\text{max}_{pos}}\\] Keyser and Hill (1999) \\(R_i\\): percentage (or proportional) reflectance at the \\(i\\)th wavelength \\(\\lambda_{max}\\), \\(\\lambda_{min}\\): upper and lower (respectively) limits of wavelengths \\(n_w\\): number of wavelength intervals used to calculate \\(B_T\\) \\(R_{max}\\), \\(R_{min}\\): maximum and minimum percent reflectances, respectively \\(\\lambda_{R_{max}}\\): wavelength at maximum reflectance \\(b\\text{max}_{neg}\\), \\(b\\text{max}_{pos}\\): maximum negative and positive slopes of reflectance curve in a region of interest \\(B_r\\), \\(B_y\\), \\(B_g\\), \\(B_b\\): total brightness in red (\\(r=625-700\\,nm\\)), yellow (\\(y=550-625\\,nm\\)), green (\\(g=475-550\\,nm\\)) and blue (\\(b=400-475\\,nm\\)) segments of the spectrum \\(\\lambda_{R_{mid}}\\): wavelength at the reflectance midpoint between \\(R_{max}\\) and \\(R_{min}\\) (i.e., \\(\\frac{R_{max}+R_{min}}{2}\\)) References "],["colour-volume-estimation.html", "Chapter 5 Colour volume estimation 5.1 \\(\\alpha\\)-shapes in chromaticity diagrams 5.2 \\(\\alpha\\)-shapes in perceptually uniform spaces 5.3 Colour volume overlap with \\(\\alpha\\)-shapes", " Chapter 5 Colour volume estimation Traditionally, colour volume or “colourfulness” of an object has been measured by computing the volume of the convex hull containing the data points, as described in (Stoddard and Prum 2008) \\(\\alpha\\)-shapes are a new tool available in pavo to estimate colour volumes, while allowing the presence of voids and pockets, which may lead to a more accurate measurement of “colourfulness” than convex hulls. For more information on the theoretical background, please report to the related article (Gruson 2020) 5.1 \\(\\alpha\\)-shapes in chromaticity diagrams You can plot the colour volume using \\(\\alpha\\)-shape with the vol() function (for non-interactive plots, tcsvol() otherwise) by specifying type = \"alpha\". By default, this will use the \\(\\alpha^*\\) value defined in Gruson (2020). library(pavo) data(flowers) vis_flowers &lt;- vismodel(flowers, visual = &quot;avg.uv&quot;) tcs_flowers &lt;- colspace(vis_flowers) plot(tcs_flowers) vol(tcs_flowers, type = &quot;alpha&quot;) ## &#39;avalue&#39; automatically set to 1.8275e-01 To get the colour volume value, you can use the summary.colspace() function. The colour volume computed by the convex hull is contained in the c.vol column and the colour volume computed by the \\(\\alpha\\)-shape (with parameter \\(\\alpha^*\\)) is contained in the a.vol column: summary(tcs_flowers) ## Colorspace &amp; visual model options: ## * Colorspace: tcs ## * Quantal catch: Qi ## * Visual system, chromatic: avg.uv ## * Visual system, achromatic: none ## * Illuminant: ideal, scale = 1 (von Kries colour correction not applied) ## * Background: ideal ## * Relative: TRUE ## * Max possible chromatic volume: 0.215735 ## &#39;avalue&#39; automatically set to 1.8275e-01 ## centroid.u centroid.s centroid.m centroid.l c.vol rel.c.vol ## all.points 0.06025649 0.2375617 0.317973 0.3842088 0.01432726 0.06617479 ## colspan.m colspan.v huedisp.m huedisp.v mean.ra max.ra ## all.points 0.2000963 0.01309332 0.7414951 0.2235526 0.8319508 0.999151 ## a.vol ## all.points 0.006057976 Alternatively, you can set the \\(\\alpha\\) parameter to the value of your choice via the avalue argument: plot(tcs_flowers) vol(tcs_flowers, type = &quot;alpha&quot;, avalue = 0.5) 5.2 \\(\\alpha\\)-shapes in perceptually uniform spaces In the previous section, we focused on \\(\\alpha\\)-shapes in chromaticity diagrams since it is the most common space where convex hulls (that \\(\\alpha\\)-shapes aim at replacing) are used. But it is also possible to use \\(\\alpha\\)-shapes in other spaces, such as perceptually uniform spaces. Let’s first build this uniform space and look at the data points in this space: cd_flowers &lt;- coldist(vis_flowers) ## Quantum catch are relative, distances may not be meaningfulFALSE ## Calculating noise-weighted Euclidean distances xy_flowers &lt;- jnd2xyz(cd_flowers) plot(xy_flowers) High-level functions to build the \\(\\alpha\\)-shape directly in pavo have not yet been implemented but you can use the alphashape3d package directly to compute the \\(\\alpha\\)-shapes, its volume and display it in a 3D interactive plot. library(alphashape3d) ## Loading required package: geometry ashape_jnd &lt;- ashape3d(as.matrix(xy_flowers), alpha = 10) volume_ashape3d(ashape_jnd) ## [1] 748.863 plot(ashape_jnd) ## Device 1 : alpha = 10 5.3 Colour volume overlap with \\(\\alpha\\)-shapes \\(\\alpha\\)-shapes can also be used to measure the colour similarity of two objects, by computing the colour volume overlap. This is done in pavo with the overlap3d() function. For example, let’s compare the colour volume of the crown and the breast of stripe-tailed yellow finches (Sicalis citrina): data(sicalis) tcs.sicalis.C &lt;- subset(colspace(vismodel(sicalis)), &quot;C&quot;) tcs.sicalis.B &lt;- subset(colspace(vismodel(sicalis)), &quot;B&quot;) voloverlap(tcs.sicalis.C, tcs.sicalis.B, type = &quot;alpha&quot;, plot = TRUE) ## &#39;avalue&#39; automatically set to 2.4445e-02 ## &#39;avalue&#39; automatically set to 2.6255e-01 ## Warning in overlap3d(colsp1, colsp2, avalue, plot, interactive, col, fill, : ## interactive = FALSE has not been implemented yet, falling back to interactive ## plot. ## vol1 vol2 s_in1 s_in2 s_inboth s_ineither psmallest pboth ## 1 1.849436e-06 4.586381e-06 3 8 0 11 0 0 References "],["references.html", "References", " References "]]
